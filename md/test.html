<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>1. 单选题</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h2 id="1-%E5%8D%95%E9%80%89%E9%A2%98">1. 单选题</h2>
<ol>
<li>下面这段程序的输出结果是</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        split(<span class="hljs-number">12</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>{
        <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) {
                System.out.print(split((number + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>));
            }
            System.out.print(split(number / <span class="hljs-number">2</span>));
        }
        <span class="hljs-keyword">return</span> number;
    }
}
</div></code></pre>
<pre><code><div>A. 63121    
B. 11236   
C. 12136   
D. 61213
</div></code></pre>
<ol start="2">
<li>已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历序列是</li>
</ol>
<pre><code><div>A. cedab   
B. cedba  
C. cebad   
D. cebda
</div></code></pre>
<ol start="3">
<li>一棵具有n个结点的完全二叉树的树高度（深度）是</li>
</ol>
<pre><code><div>A. log2(n)+1  
B. [log2(n)]
C. [log2(n)]+1 
D. log2(n)-1
</div></code></pre>
<ol start="4">
<li>下面这段程序的输出结果是</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"A的构造函数"</span>);
    }
    {
        System.out.println(<span class="hljs-string">"A的构造代码块"</span>);
    }
    <span class="hljs-keyword">static</span> {
        System.out.println(<span class="hljs-string">"A的静态代码块"</span>);
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"B的构造函数"</span>);
    }
    {
        System.out.println(<span class="hljs-string">"B的构造代码块"</span>);
    }
    <span class="hljs-keyword">static</span> {
        System.out.println(<span class="hljs-string">"B的静态代码块"</span>);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        A a = <span class="hljs-keyword">new</span> A();
        B b = <span class="hljs-keyword">new</span> B();
    }
}
</div></code></pre>
<pre><code><div>A. A的静态代码块 A的构造代码块 A的构造函数 A的构造代码块 
A的构造函数 B的静态代码块 B的构造代码块 B的构造函数
B. A的静态代码块 A的构造函数 A的构造代码块 A的构造函数 
A的构造代码块 B的静态代码块 B的构造函数 B的构造代码块 
C. A的静态代码块 A的构造代码块 A的构造函数 B的静态代码块
A的构造代码块 A的构造函数 B的构造代码块 B的构造函数
D. A的静态代码块 A的构造代码块 A的构造函数 B的静态代码块 
B的构造代码块 B的构造函数
</div></code></pre>
<ol start="5">
<li>下面这段程序的输出结果是</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String a = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"myString"</span>);
        String b = <span class="hljs-string">"myString"</span>;
        String c = <span class="hljs-string">"my"</span> + <span class="hljs-string">"String"</span>;
        String d = c;
        System.out.print(a == b);
        System.out.print(a == c);
        System.out.print(b == c);
        System.out.print(b == d);
    }
}
</div></code></pre>
<pre><code><div>A. falsefalsetruetrue 
B. truetruefalsefalse
C. falsetruetruefalse
D. falsetruefalsetrue
</div></code></pre>
<ol start="6">
<li>Service提供的回调方法中，哪一个方法在生命周期中可能被多次回调</li>
</ol>
<pre><code><div>A. onCreate
B. onStart
C. onBind
D. onDestory
</div></code></pre>
<ol start="7">
<li>⼀个完全⼆叉树中有330个叶子节点, 则在该⼆叉树中的节点个数为</li>
</ol>
<pre><code><div>A. 659
B. 660
C. 可能为659或者660
D. 不可能为659和660
</div></code></pre>
<ol start="8">
<li>关于http请求里post和get描述不正确的是</li>
</ol>
<pre><code><div>A. POST请求的数据不会暴露在地址栏中
B. GET请求的URL中不能携带数据参数
C. 根据HTTP规范，POST表示可能修改变服务器上的资源的请求
D. 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的
</div></code></pre>
<ol start="9">
<li>android提供的跨进程通讯方式不包括以下哪个</li>
</ol>
<pre><code><div>A. Content Provider
B. Broadcast
C. AIDL
D. service
</div></code></pre>
<ol start="10">
<li>android的view控件从被创建到显示，不会经过以下哪个方法</li>
</ol>
<pre><code><div>A. onDraw
B. onMeasure
C. onAdd
D. onLayout
</div></code></pre>
<h2 id="2-%E5%A4%9A%E9%80%89%E9%A2%98">2. 多选题</h2>
<ol>
<li>在使用super和this关键字时，以下描述错误的是</li>
</ol>
<pre><code><div>A. super()和this()不一定要放在构造方法内第一行
B. this()和super()可以同时出现在一个构造函数中
C. this()和super()可以在static环境中使用，
包括static方法和static语句块
D. 在子类构造方法中使用super()显示调用父类的构造方法，
super()必须写在子类构造方法的第一行，否则编译不通过
</div></code></pre>
<ol start="2">
<li>关于广播说法正确的是</li>
</ol>
<pre><code><div>A. 动态注册的广播不解除注册也没关系
B. 有序广播是可以被拦截的
C. 当静态注册的广播设置的优先级高于动态注册的广播时，
静态注册将先接收到广播
D. 可以通过指定包名来发送定向广播
</div></code></pre>
<ol start="3">
<li>关于IntentService和Service以下说法正确的是</li>
</ol>
<pre><code><div>A. IntentService任务执行完后会自动停止，service不会自动停止
B. Intentservice和service都需要创建新的线程来执行耗时任务
C. 每次启动IntentService,它的onStartCommand方法就会调用一次
D. 提交多个任务给IntentService,这些任务是并行执行的
</div></code></pre>
<ol start="4">
<li>Intent可以传递的数据类型包括</li>
</ol>
<pre><code><div>A. Bundle
B. Serializable
C. CharSequence
D. Parcelable
</div></code></pre>
<ol start="5">
<li>下列哪几种情况可能会导致系统ANR</li>
</ol>
<pre><code><div>A. Activity的onCreate方法中进行耗时操作
B. IntentService的onHandleIntent方法中进行耗时操作
C. Broadcaster的onReceive方法中进行耗时操作
D. ContentProvider的onCreate方法中进行耗时操作
</div></code></pre>
<ol start="6">
<li>下列哪几种情况可能会导致内存泄露</li>
</ol>
<pre><code><div>A. 单实例类中包含Acitvity Context成员变量
B. Activity使用AsyncTask执行耗时较长的任务时，频繁进行横竖屏切换操作
C. Activity中包含匿名Thread内部类，该Thread一直在后台运行
D. Activity的onCreate中进行大量内存申请操作
</div></code></pre>
<ol start="7">
<li>下列关于synchronized的描述，那几项是正确的</li>
</ol>
<pre><code><div>A. 一个线程访问对象的synchronized(this)同步代码块时，
其它线程可以访问该对象中的其它synchronized(this)同步代码块
B. 一个线程访问对象的synchronized(this)同步代码块时，
其它线程可以访问该对象中的synchronized(otherLock)同步代码块
C. 两个并发线程访问同一个对象中的synchronized(this)
同步代码块时，同一时间内只能有一个线程拥有执行权
D. Object的wait()和notify()函数，只能在synchronized代码块中使用
</div></code></pre>
<ol start="8">
<li>下列关于 Java 中多线程的描述，哪几项是正确的</li>
</ol>
<pre><code><div>A. 一个线程可以调用 yield 方法使其他线程有机会运行
B. 一个线程在调用它的 start 方法之前，将一直处于出生期
C. 高优先级的可运行线程会抢占低优先级线程
D. 一个线程访问对象的synchronized(this)同步代码块时，
其它线程可以访问该对象中的其它synchronized(this)同步代码块
</div></code></pre>
<ol start="9">
<li>以下集合对象中哪几个是线程安全的</li>
</ol>
<pre><code><div>A. ArrayList
B. Vector
C. Hashtable
D. Stack
</div></code></pre>
<ol start="10">
<li>关于java内存的描述不正确的是</li>
</ol>
<pre><code><div>A. java中有GC机制，所以不会出现内存溢出的情况
B. 有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
C. 当GC执行时，会挂起其他线程的工作
D. 当开发人员把一个成员变量置空后，该对象占用的内存空间就会立马释放
</div></code></pre>
<h2 id="3-%E5%A1%AB%E7%A9%BA%E9%A2%98">3. 填空题</h2>
<ol>
<li>从A切换到B activity时，会依次调用B生命周期的_____________________________________函数。</li>
<li>一个有i层的二叉树，他的最小、最大节点数分别是_________、______________。</li>
<li>一个Handler允许发送和处理____________或者_____________对象，并且会关联到主线程的MessageQueue中。</li>
<li>若一序列进栈顺序为a1,a2,a3,a4，存在_____种可能的出栈序列。</li>
<li>Activity的launchMode有___________________________________________________________。</li>
</ol>
<h2 id="4-%E7%AE%97%E6%B3%95%E9%A2%98">4. 算法题</h2>
<ol>
<li>反转一个单链表。</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-comment">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{
       
    }
}
</div></code></pre>
<ol start="2">
<li>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-comment">/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;
    }
}
*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="hljs-keyword">int</span> target) {

    }
}
</div></code></pre>
<ol start="3">
<li>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>{
   
    }
}
</div></code></pre>
<ol start="4">
<li>给一个数组，返回它的最大连续子序列的和，例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>{

    }
}
</div></code></pre>
<ol start="5">
<li>快速排序代码实现</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>{

    }
}
</div></code></pre>
<hr>
<h2 id="%E7%AD%94%E6%A1%88">答案</h2>
<p>单选 1-10</p>
<p>CBCCABCBDC</p>
<p>多选 1-10</p>
<ol>
<li>ABC</li>
<li>BD</li>
<li>AC</li>
<li>ABCD</li>
<li>ACD</li>
<li>ABC</li>
<li>BCD</li>
<li>ABC</li>
<li>BCD</li>
<li>AD</li>
</ol>
<p>填空</p>
<ol>
<li>onCreate，onStart， onResume</li>
<li>i，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>Message,Runnable</li>
<li>14</li>
<li>standard，singleTop，singleTask，singleInstance</li>
</ol>
<p>算法</p>
<ol>
<li>考察链表的操作</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{
        ListNode prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//前指针节点</span>
        ListNode curr = head; <span class="hljs-comment">//当前指针节点</span>
        <span class="hljs-comment">//每次循环，都将当前节点指向它前面的节点，然后当前节点和前节点后移</span>
        <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) {
            ListNode nextTemp = curr.next; 
            <span class="hljs-comment">//临时节点，暂存当前节点的下一节点，用于后移</span>
            curr.next = prev; <span class="hljs-comment">//将当前节点指向它前面的节点</span>
            prev = curr; <span class="hljs-comment">//前指针后移</span>
            curr = nextTemp; <span class="hljs-comment">//当前指针后移</span>
        }
        <span class="hljs-keyword">return</span> prev;
    }
}
</div></code></pre>
<ol start="2">
<li>考察二叉树，递归</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = 
                        <span class="hljs-keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
    <span class="hljs-keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="hljs-keyword">int</span> target) {
        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> listAll;
        list.add(root.val);
        target -= root.val;
        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)
            listAll.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(list));
        FindPath(root.left, target);
        FindPath(root.right, target);
        list.remove(list.size()-<span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> listAll;
    }
}
</div></code></pre>
<ol start="3">
<li>考察数组</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>{
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>;i&lt;array.length-<span class="hljs-number">1</span>;i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;array.length-<span class="hljs-number">1</span>-i;j++){
                <span class="hljs-keyword">if</span>(array[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;array[j+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>){
                    <span class="hljs-keyword">int</span> t = array[j];
                    array[j]=array[j+<span class="hljs-number">1</span>];
                    array[j+<span class="hljs-number">1</span>]=t;
                }
            }
        }
    }
}
</div></code></pre>
<ol start="4">
<li>考察动态规划</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>{
        <span class="hljs-keyword">int</span> res = array[<span class="hljs-number">0</span>]; <span class="hljs-comment">//记录当前所有子数组的和的最大值</span>
        <span class="hljs-keyword">int</span> max = array[<span class="hljs-number">0</span>];   <span class="hljs-comment">//包含array[i]的连续数组最大值</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.length; i++) {
            max=Math.max(max+array[i], array[i]);
            res=Math.max(max, res);
        }
        <span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<ol start="5">
<li>考察排序算法</li>
</ol>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> hight)</span> </span>{
        <span class="hljs-keyword">int</span> i, j, index;
        <span class="hljs-keyword">if</span> (low &gt; hight) {
            <span class="hljs-keyword">return</span>;
        }
        i = low;
        j = hight;
        index = a[i]; <span class="hljs-comment">// 用子表的第一个记录做基准</span>
        <span class="hljs-keyword">while</span> (i &lt; j) { <span class="hljs-comment">// 从表的两端交替向中间扫描</span>
            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= index)
                j--;
            <span class="hljs-keyword">if</span> (i &lt; j)
                a[i++] = a[j];<span class="hljs-comment">// 用比基准小的记录替换低位记录</span>
            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt; index)
                i++;
            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-comment">// 用比基准大的记录替换高位记录</span>
                a[j--] = a[i];
        }
        a[i] = index;<span class="hljs-comment">// 将基准数值替换回 a[i]</span>
        sort(a, low, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 对低子表进行递归排序</span>
        sort(a, i + <span class="hljs-number">1</span>, hight); <span class="hljs-comment">// 对高子表进行递归排序</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[])</span> </span>{
        sort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);
    }
}
</div></code></pre>

    </body>
    </html>