<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>华为、小米、OPPO、vivo、魅族推送服务</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="%e5%8d%8e%e4%b8%ba%e5%b0%8f%e7%b1%b3oppovivo%e9%ad%85%e6%97%8f%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1">华为、小米、OPPO、vivo、魅族推送服务</h1>
<p>参考：</p>
<blockquote>
<p><a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_introduction_agent">华为推送服务</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_c1">华为推送客户端API参考</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_s1">华为推送服务端API参考</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mi.com/console/doc/detail?pId=100">小米推送Android版快速接入指南</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mi.com/console/doc/detail?pId=41">小米推送服务Android版客户端SDK使用指南</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mi.com/console/doc/detail?pId=1278">小米服务端Java SDK文档</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.mi.com/console/doc/detail?pId=1163">小米服务器API地址以及参数</a></p>
</blockquote>
<blockquote>
<p><a href="https://open.oppomobile.com/wiki/doc#id=10195">OPPO PUSH服务开启指南</a></p>
</blockquote>
<blockquote>
<p><a href="https://open.oppomobile.com/wiki/doc#id=10196">OPPO PUSH SDK接口文档</a></p>
</blockquote>
<blockquote>
<p><a href="https://open.oppomobile.com/wiki/doc#id=10203">OPPO PUSH服务端java SDK接入指南</a></p>
</blockquote>
<blockquote>
<p><a href="https://open.oppomobile.com/wiki/doc#id=10201">OPPO SDK下载</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.vivo.com.cn/documentCenter/doc/180">vivo推送产品说明</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.vivo.com.cn/documentCenter/doc/233">vivo Android PUSH-SDK API集成指南</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.vivo.com.cn/documentCenter/doc/232">vivo Android PUSH-SDK API接口文档</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.vivo.com.cn/documentCenter/doc/197">vivo 服务端 SDK文档</a></p>
</blockquote>
<blockquote>
<p><a href="https://dev.vivo.com.cn/documentCenter/doc/155">vivo 服务端 PUSH-UPS-API接口文档</a></p>
</blockquote>
<blockquote>
<p><a href="http://open.res.flyme.cn/fileserver/upload/file/201612/728a49f530c64c5a832d7ba1de69e356.pdf">Flyme推送接入文档</a></p>
</blockquote>
<blockquote>
<p><a href="http://open.res.flyme.cn/fileserver/upload/file/201907/054259cd57014629b91db6b10a158ba3.pdf">Flyme推送Android客户端SDK文档</a></p>
</blockquote>
<blockquote>
<p><a href="http://open.res.flyme.cn/fileserver/upload/file/201803/be1f71eac562497f92b42c750196a062.pdf">Flyme推送HTTP接口文档</a></p>
</blockquote>
<blockquote>
<p><a href="http://open.res.flyme.cn/fileserver/upload/file/201803/e174a5709f134f64aae3fb168aec8ea3.pdf">Flyme推送JAVA版本SDK接口文档</a></p>
</blockquote>
<blockquote>
<p><a href="http://open.res.flyme.cn/fileserver/upload/file/201907/c6ab8b399ad0482bbaff5b59e2cfc27c.rar">Flyme推送SDK</a></p>
</blockquote>
<blockquote>
<p><a href="http://open.res.flyme.cn/fileserver/upload/file/201804/faa5ef883f6f4e74b9aaf550644dfe0e.zip">Flyme推送服务端JAVA SDK</a></p>
</blockquote>
<ul>
<li>通知栏消息 （五个推送服务都支持）</li>
</ul>
<p>比如我们的IM消息通知，一般会显示在通知栏中，点击通知栏消息触发相应的动作，比如打开session、打开指定应用等等。</p>
<ul>
<li>透传消息 （仅华为小米支持）</li>
</ul>
<p>透传消息由开发者的APP自主解析自定义内容，并触发相关动作，比如我们的Meeting、PBX通知，会直接拉起一个界面。</p>
<h2 id="1-%e5%8d%8e%e4%b8%ba%e6%8e%a8%e9%80%81%e5%ae%a2%e6%88%b7%e7%ab%af%e5%bc%80%e5%8f%91">1. 华为推送客户端开发</h2>
<p><strong>如果需要在非华为系统EMUI的Android设备上使用华为推送服务，则需要额外安装HMS APK（华为移动服务），华为设备出厂自带不需要安装</strong></p>
<ol>
<li>PUSH消息首次发送，应用在线联网的情况下，时延在1s内。如果受限于网络环境的情况，消息时延无法保证。</li>
<li>PUSH消息支持的Android APP包名称最大为128个字节，消息内容最大限制为2K。</li>
<li>开发者应用服务器短时间内频繁申请Access Token会被网关流控，返回error=6错误码。</li>
<li>开发者应用服务器短时间内发送大量的推送消息会被流控，返回HTTP 503状态码。</li>
</ol>
<p><img src="file:///e:\pythonprojects\craft\md\Android\push\hms.png" alt=""></p>
<h3 id="11-%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c">1.1 准备工作</h3>
<p>集成华为推送服务需要完成以下几个步骤：</p>
<ol>
<li>注册认证成为开发者</li>
<li>配置应用签名</li>
<li>创建产品和应用</li>
<li>开通推送服务</li>
<li>下载SDK</li>
<li>集成工程</li>
</ol>
<p>其中前4个步骤可以参考<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_devprepare_agent#4%20%E5%BC%80%E9%80%9A%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1">开发准备</a>，在华为推送相关网站完成。</p>
<p><strong>配置应用签名这个步骤非常重要，需要获取keystore的证书指纹SHA256</strong></p>
<p>这里重点说明一下SDK获取和项目集成，使用第三方推送服务一般都需要第三方PUSH服务器转发我们服务器发送的推送消息，因此在这个过程中客户端需要向第三方PUSH服务器请求token以及处理从PUSH服务器传过来的推送消息，一般来说第三方服务提供商就会提供集成了这些功能的SDK，因此我们需要将第三方SDK导入我们的项目中。</p>
<p>以华为推送为例，使用华为推送除了需要SDK，还需要HMS SDK Agent，HMS SDK Agent提供可以直接使用的接口；华为SDK可以通过Gradle+maven方式导入，HMS SDK Agent需要手动导入。</p>
<blockquote>
<p>1.gradle中加入华为的仓库</p>
</blockquote>
<pre><code class="language-gradle"><div><span class="hljs-keyword">allprojects</span> {
    <span class="hljs-keyword">repositories</span> {
        google()
        jcenter()
        maven {
            url <span class="hljs-string">'http://developer.huawei.com/repo/'</span>
        }
    }
}
</div></code></pre>
<blockquote>
<p>2.配置编译依赖</p>
</blockquote>
<pre><code class="language-gradle"><div> <span class="hljs-keyword">dependencies</span> {
    implementation <span class="hljs-string">'com.huawei.android.hms:push:2.6.1.301'</span>
  }        
</div></code></pre>
<blockquote>
<p>3.手动导入HMS SDK Agent，下载<a href="https://obs.cn-north-2.myhwclouds.com/hms-ds-wf/sdk/HMSAgent_2.6.3.301.zip">HMSAgent_{version}.zip</a>，使用windows批处理脚本GetHMSAgent_cn.bat提取出PUSH模块，相关文件会保存到copysrc\文件夹下，然后将copysrc/java里面的代码拷到项目中去；</p>
</blockquote>
<blockquote>
<p>4.配置manifest文件</p>
</blockquote>
<p><strong>在application节点下增加APPID</strong></p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>  
    <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.hms.client.appid"</span>  
    &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">value</span>的值“<span class="hljs-attr">xxx</span>”用实际申请的应用<span class="hljs-attr">ID</span>替换，来源于开发者联盟网站应用的服务详情。<span class="hljs-attr">--</span>&gt;</span>  
    android:value="appid=xxx"&gt;  
<span class="hljs-tag">&lt;/<span class="hljs-name">meta-data</span>&gt;</span>    
</div></code></pre>
<p><strong>配置application的name属性， 用于在application启动的时候调用HMSAgent.init()接口初始化HMS Agent套件，开发者需自己实现应用的MyApplication类</strong></p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">application</span>

    &lt;!<span class="hljs-attr">--</span> “<span class="hljs-attr">xxx</span>”用实际的应用包名替换<span class="hljs-attr">--</span>&gt;</span>
    android:name="xxx.xxx.xxx.MyApplication"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/AppTheme"&gt;
</div></code></pre>
<p><strong>在application节点下增加activity。BridgeActivity定义了HMS SDK中一些跳转所需要的透明页面</strong></p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>  
    <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.hms.activity.BridgeActivity"</span>  
    <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">"orientation|locale|screenSize|layoutDirection|fontScale"</span>  
    <span class="hljs-attr">android:excludeFromRecents</span>=<span class="hljs-string">"true"</span>  
    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>  
    <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>  
    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@android:style/Theme.Translucent"</span> &gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>  
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"hwc-theme"</span>  
        <span class="hljs-attr">android:value</span>=<span class="hljs-string">"androidhwext:style/Theme.Emui.Translucent"</span> /&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>   
</div></code></pre>
<p><strong>AppUpdateActivity和PackageInstallActivity是应用自升级接口所需要使用的页面</strong></p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
    <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.updatesdk.service.otaupdate.AppUpdateActivity"</span>
    <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">"orientation|screenSize"</span>
    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>
    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/upsdkDlDialog"</span> &gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"hwc-theme"</span>
        <span class="hljs-attr">android:value</span>=<span class="hljs-string">"androidhwext:style/Theme.Emui.Translucent.NoTitleBar"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
    <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.updatesdk.support.pm.PackageInstallerActivity"</span>
    <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">"orientation|keyboardHidden|screenSize"</span>
    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>
    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/upsdkDlDialog"</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"hwc-theme"</span>
        <span class="hljs-attr">android:value</span>=<span class="hljs-string">"androidhwext:style/Theme.Emui.Translucent"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>
</div></code></pre>
<p><strong>在application节点下增加UpdateProvider，用于HMS SDK引导升级HMS APK，提供给系统安装器读取升级文件</strong></p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">provider</span>  
    <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.hms.update.provider.UpdateProvider"</span>  
    &lt;!<span class="hljs-attr">--</span>“<span class="hljs-attr">xxx.xxx.xxx</span>”用实际的应用包名替换<span class="hljs-attr">--</span>&gt;</span>  
    android:authorities="xxx.xxx.xxx.hms.update.provider"  
    android:exported="false"  
    android:grantUriPermissions="true" &gt;  
<span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span>
</div></code></pre>
<p><strong>在application节点下增加Service，用于应用自升级</strong></p>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!-- 应用下载服务 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.updatesdk.service.deamon.download.DownloadService"</span>
    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>/&gt;</span>    
</div></code></pre>
<p><strong>在manifest节点下增加所需权限</strong></p>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!--HMS-SDK引导升级HMS功能，访问OTA服务器需要网络权限--&gt;</span>    
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /&gt;</span>    
<span class="hljs-comment">&lt;!--HMS-SDK引导升级HMS功能，保存下载的升级包需要SD卡写权限--&gt;</span>    
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span>    
<span class="hljs-comment">&lt;!--检测网络状态--&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span>  
<span class="hljs-comment">&lt;!--检测wifi状态--&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_WIFI_STATE"</span>/&gt;</span>  
<span class="hljs-comment">&lt;!--为了获取用户手机的IMEI，用来唯一的标识用户。--&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.READ_PHONE_STATE"</span>/&gt;</span> 

<span class="hljs-comment">&lt;!--如果是安卓8.0，应用编译配置的targetSdkVersion&gt;=26，请务必添加以下权限 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.REQUEST_INSTALL_PACKAGES"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 接收PUSH TOKEN的广播以及PUSH消息需要定义该权限 ${PACKAGE_NAME} 要替换上您应用的包名 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">permission</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"${PACKAGE_NAME}.permission.PROCESS_PUSH_MSG"</span>
        <span class="hljs-attr">android:protectionLevel</span>=<span class="hljs-string">"signatureOrSystem"</span>/&gt;</span>

<span class="hljs-comment">&lt;!--接收PUSH TOKEN的广播以及PUSH消息需要定义该权限 ${PACKAGE_NAME} 要替换上您应用的包名 --&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"${PACKAGE_NAME}.permission.PROCESS_PUSH_MSG"</span> /&gt;</span>
</div></code></pre>
<p><strong>在application节点下声明2个receiver和1个service，用于接收广播信息，用于接收PUSH Token，透传消息和通知栏点击消息</strong></p>
<pre><code class="language-xml"><div>  <span class="hljs-comment">&lt;!-- 接入HMSSDK PUSH模块需要注册，第三方相关 :接收Push消息（注册、透传消息、通知栏点击事件）广播，此receiver类需要开发者自己创建并继承com.huawei.hms.support.api.push.PushReceiver类，参考示例代码中的类：com.huawei.hmsagent.HuaweiPushRevicer--&gt;</span>

  <span class="hljs-comment">&lt;!--“xxx”用实际的类名替换, ${PACKAGE_NAME} 要替换上您应用的包名--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"xxx"</span>
         <span class="hljs-attr">android:permission</span>=<span class="hljs-string">"${PACKAGE_NAME}.permission.PROCESS_PUSH_MSG"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
               <span class="hljs-comment">&lt;!-- 必须,用于接收token --&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.android.push.intent.REGISTRATION"</span> /&gt;</span>
               <span class="hljs-comment">&lt;!-- 必须, 用于接收透传消息 --&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.android.push.intent.RECEIVE"</span> /&gt;</span>
               <span class="hljs-comment">&lt;!-- 必须, 用于接收通知栏消息点击事件 此事件不需要开发者处理，只需注册就可以--&gt;</span>
               <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.intent.action.PUSH_DELAY_NOTIFY"</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>
</div></code></pre>
<p><strong>用于点击通知栏或通知栏上按钮后触发onEvent回调，这个通知会在后续版本中逐渐废弃，请开发者谨慎使用</strong></p>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!--如下2个通知会在以后的版本中逐渐废弃 
            接入HMSSDK PUSH模块需要注册，第三方相关 :接收Push消息（点击通知栏或通知栏上的按钮后触发onEvent回调、查看push通道是否连接）广播，          此receiver类需要开发者自己创建并继承com.huawei.hms.support.api.push.PushReceiver类，参考示例代码中的类：com.huawei.hmsagent.HuaweiPushRevicer类 --&gt;</span>

  <span class="hljs-comment">&lt;!--“xxx”用实际的类名替换, ${PACKAGE_NAME} 要替换上您应用的包名--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"xxxx"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 用于点击通知栏或通知栏上的按钮后触发onEvent回调 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.android.push.intent.CLICK"</span> /&gt;</span>
            <span class="hljs-comment">&lt;!-- 查看push通道是否连接, 不查看则不需要 --&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.intent.action.PUSH_STATE"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>
</div></code></pre>
<p><strong>如果应用需要在非华为设备上使用PUSH，需要声明HmsMsgService</strong></p>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!--接入HMSSDK PUSH模块需要注册该service，不需要开发者处理--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">service</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.hms.support.api.push.service.HmsMsgService"</span>
        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">android:process</span>=<span class="hljs-string">":pushservice"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.push.msg.NOTIFY_MSG"</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.push.msg.PASSBY_MSG"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span>     
</div></code></pre>
<p><strong>在application节点下注册android组件，解决华为移动服务升级问题的透明界面</strong></p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
    <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.huawei.android.hms.agent.common.HMSAgentActivity"</span>
    <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">"orientation|locale|screenSize|layoutDirection|fontScale"</span>
    <span class="hljs-attr">android:excludeFromRecents</span>=<span class="hljs-string">"true"</span>
    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>
    <span class="hljs-attr">android:hardwareAccelerated</span>=<span class="hljs-string">"true"</span>
    <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@android:style/Theme.Translucent"</span> &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">"hwc-theme"</span>
        <span class="hljs-attr">android:value</span>=<span class="hljs-string">"androidhwext:style/Theme.Emui.Translucent"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>    
</div></code></pre>
<blockquote>
<p>5.配置混淆脚本</p>
</blockquote>
<p><a href="http://proguard-rules.pro">proguard-rules.pro</a></p>
<pre><code class="language-pro"><div>-ignorewarning
-keepattributes *Annotation*
-keepattributes Exceptions
-keepattributes InnerClasses
-keepattributes Signature
-keepattributes SourceFile,LineNumberTable
-keep class com.hianalytics.android.**{*;}
-keep class com.huawei.updatesdk.**{*;}
-keep class com.huawei.hms.**{*;}

-keep class com.huawei.android.hms.agent.**{*;}
</div></code></pre>
<h3 id="12-%e5%ae%a2%e6%88%b7%e7%ab%af%e5%bc%80%e5%8f%91">1.2 客户端开发</h3>
<p>HMS Agent 套件提供了对HMS SDK原生接口的二次封装，处理了部分必要的接入逻辑而不再将它们暴露给开发者，使用封装后的Agent接口接入HMS SDK，可大大提升接入效率，降低出错几率。</p>
<blockquote>
<p>1.初始化</p>
</blockquote>
<p>请务必在application的onCreate方法中初始化HMS Agent套件。如果没有自己的application类，请创建MyApplication类，并在manifest文件中配置application节点的name属性。</p>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.onCreate();
        HMSAgent.init(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTerminate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.onTerminate();
        HMSAgent.destroy();
    }
}
</div></code></pre>
<blockquote>
<p>2.调用connect</p>
</blockquote>
<p>请务必在应用启动后的首个activity的onCreate方法中调用connect接口，确保HMS SDK和HMS APK的连接。</p>
<pre><code class="language-java"><div>HMSAgent.connect(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> ConnectHandler() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onConnect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rst)</span> </span>{
        showLog(<span class="hljs-string">"HMS connect end:"</span> + rst);
    }
});    
</div></code></pre>
<blockquote>
<p>3.申请token</p>
</blockquote>
<pre><code class="language-java"><div>HMSAgent.Push.getToken(<span class="hljs-keyword">new</span> GetTokenHandler() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rtnCode)</span> </span>{
        Log.i(<span class="hljs-string">"get token: end code="</span> , String.valueOf(rtnCode));
    }
});
</div></code></pre>
<p>建议开发者在首个activity的onCreate方法调用getToken方法，同一个手机的同一个应用获取的Token不会变，但是建议每次启动更新一次PUSH token。调用getToken接口后，Token不是在本接口中直接返回的，而是通过广播的形式通知APP因此需要开发者实现自定义广播的onToken方法来接收Token。</p>
<blockquote>
<p>4.自定义广播接收消息</p>
</blockquote>
<p>PUSH Token的返回，PUSH服务器发送的透传消息以及通知栏点击事件的处理都是通过广播来接收，因此开发者需要实现自定义广播，开发者需要创建子类继承com.huawei.hms.support.api.push.PushReceiver，实现onToken，onPushMsg，onEvent这几个方法，用于接收Token返回，透传消息和通知栏点击事件处理。</p>
<p><strong>onEvent会在后续版本中逐渐废弃，请开发者谨慎使用</strong></p>
<p>由于是通过广播触发，所以当应用的进程不存在时可能由于系统原因无法通过广播方式拉起应用处理通知栏点击事件等。需要在手机上面为应用设置“允许自启动”才能在进程不存在时正常处理PushReceiver的广播</p>
<p><strong>确保开发准备中manifest.xml的配置已完成</strong></p>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaweiPushReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PushReceiver</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onToken</span><span class="hljs-params">(Context context, String token, Bundle extras)</span> </span>{

               <span class="hljs-comment">//开发者自行实现Token保存逻辑。</span>
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onPushMsg</span><span class="hljs-params">(Context context, <span class="hljs-keyword">byte</span>[] msg, Bundle bundle)</span> </span>{

               <span class="hljs-comment">//开发者自行实现透传消息处理。</span>
    }  

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(Context context, Event event, Bundle extras)</span> </span>{

                <span class="hljs-comment">//开发者自行实现相应处理逻辑</span>
    }  
 }    
</div></code></pre>
<p>PUSH服务器返回Token后，开发者需要在onToken回调方法中将Token妥善的保存起来，例如存放到开发者的应用服务器上，此业务逻辑需要开发者自行实现。后续如果开发者的应用服务器实现了调用华为PUSH服务器端接口发送推送消息，开发者就可以向这些保存Token发送批量推送消息，此业务需要开发者参考实现《服务端开发》章节。</p>
<p>如果有涉及到在APP客户端和开发者自己的服务器之前传输Token,请开发者自行确保Token传输的安全。</p>
<p><strong>删除PUSH Token（可选）</strong></p>
<p>开发者如果不希望应用接收PUSH消息，可以调用deleteToken接口删除token，删除成功后，客户端就不会再接收到PUSH消息。但是建议开发者暂时不要依赖deleteToken接口，如果开发者要实现不接收PUSH消息，可以自行将开发者应用服务器端的Token状态设置为失效状态，并且在推送消息时判断是失效Token就不进行推送，避免频繁的向服务器申请token。</p>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteToken</span><span class="hljs-params">()</span></span>{
        showLog(<span class="hljs-string">"deleteToken:begin"</span>);
        HMSAgent.Push.deleteToken(token, <span class="hljs-keyword">new</span> DeleteTokenHandler() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rst)</span> </span>{
                showLog(<span class="hljs-string">"deleteToken:end code="</span> + rst);
            }
        });
    }
</div></code></pre>
<p><strong>是否接收PUSH通知栏消息（可选）</strong></p>
<p>如果开发者不调用此方法，默认是接收通知栏消息。在某些情况下，开发者如果想控制应用是否接收通知栏消息，可以调用此接口。</p>
<pre><code class="language-java"><div><span class="hljs-comment">/**
    * 设置接收通知消息 | Set up receive notification messages
    * <span class="hljs-doctag">@param</span> enable 是否开启 | enabled or not
    */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReceiveNotifyMsg</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enable)</span></span>{
    showLog(<span class="hljs-string">"enableReceiveNotifyMsg:begin"</span>);
    HMSAgent.Push.enableReceiveNotifyMsg(enable, <span class="hljs-keyword">new</span> EnableReceiveNotifyMsgHandler() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rst)</span> </span>{
            showLog(<span class="hljs-string">"enableReceiveNotifyMsg:end code="</span> + rst);
        }
    });
}    
</div></code></pre>
<p><strong>是否接收PUSH透传消息（可选）</strong></p>
<p>如果开发者不调用此方法，默认是接收透传消息。在某些情况下，开发者如果想控制应用是否接收透传的PUSH消息，可以调用此接口。</p>
<pre><code class="language-java"><div><span class="hljs-comment">/**
    * 设置是否接收普通透传消息 | Set whether to receive normal pass messages
    * <span class="hljs-doctag">@param</span> enable 是否开启 | enabled or not
    */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReceiveNormalMsg</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enable)</span></span>{
    showLog(<span class="hljs-string">"enableReceiveNormalMsg:begin"</span>);
    HMSAgent.Push.enableReceiveNormalMsg(enable, <span class="hljs-keyword">new</span> EnableReceiveNormalMsgHandler() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rst)</span> </span>{
            showLog(<span class="hljs-string">"enableReceiveNormalMsg:end code="</span> + rst);
        }
    });
} 
</div></code></pre>
<h3 id="13-%e5%ae%a2%e6%88%b7%e7%ab%af%e6%b5%8b%e8%af%95">1.3 客户端测试</h3>
<p>至此开发者已经完成了所有PUSH功能客户端的开发，开发者可以尝试将自己的android工程打包成apk安装到手机中进行测试，打包的时候请确保使用了正确的keystore证书，打包完成后开发者可以使用keytool命令获取apk的证书指纹，apk中的SHA256指纹信息必须和开发者在开发者联盟上创建应用的指纹保持一致。否则请检查apk打包过程的正确性。</p>
<p>如果需要测试客户端配置是否成功，可以通过<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_apptest_agent">“PUSH控制台发送测试消息”</a>来测试PUSH消息能否正确送达客户端。</p>
<h2 id="2-%e5%8d%8e%e4%b8%ba%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%bc%80%e5%8f%91">2. 华为推送服务端开发</h2>
<p><img src="file:///e:\pythonprojects\craft\md\Android\push\hms1.png" alt=""></p>
<p>客户端开发：</p>
<ul>
<li>STEP1开发者的APP集成HMS SDK，调用getToken接口从PUSH服务器获取到PUSH Token。</li>
<li>STEP2开发者的APP对于获取到的PUSH Token需要上报到开发者自己的服务器APP Provider Server上。</li>
</ul>
<p>服务端开发：</p>
<ul>
<li>STEP3开发者利用服务器上保存的PUSH Token向对应的终端设备发送通知消息。</li>
<li>STEP4消息携带的PUSH Token作为鉴权和路由机制会通过华为PUSH平台将消息发送到最终用户设备上。</li>
</ul>
<h3 id="21-%e5%ba%94%e7%94%a8%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%8e%b7%e5%8f%96accesstoken">2.1 应用服务器获取AccessToken</h3>
<p>接口名：<a href="https://login.cloud.huawei.com/oauth2/v2/token%EF%BC%8C%E6%8E%A5%E5%8F%A3%E8%AF%A6%E7%BB%86%E5%AE%9A%E4%B9%89%E5%8F%82%E8%A7%81%E8%AF%B7%E6%B1%82">https://login.cloud.huawei.com/oauth2/v2/token，接口详细定义参见请求</a><a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_s1">Access Token</a>。</p>
<p>接口说明：开发者应用服务器调用请求Access Token接口获取接入令牌，Access Token是应用服务器发送PUSH 消息的必须参数。</p>
<p>Access Token存在有效期，当前有效期为1个小时，未来可能有变动，有效期通过响应参数消息的expires_in参数传达。Access Token在有效期内请尽量复用，如果开发者应用服务器频繁的申请Access Token，可能会被流控。Access Token过期前，业务要根据这个有效时间提前去申请新Access Token。业务在API调用获知Access Token已经超过的情况下（NSP_STATUS=6），需要触发access_token的申请流程。</p>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PushNcMsg</span>
</span>{ 

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String appSecret = <span class="hljs-string">"appSecret"</span>;<span class="hljs-comment">//用户在华为开发者联盟申请Push服务获取的服务参数</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  String appId = <span class="hljs-string">"12345678"</span>;<span class="hljs-comment">//用户在华为开发者联盟申请Push服务获取的服务参数</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  String tokenUrl = <span class="hljs-string">"https://login.cloud.huawei.com/oauth2/v2/token"</span>; <span class="hljs-comment">//获取认证Token的URL</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  String apiUrl = <span class="hljs-string">"https://api.push.hicloud.com/pushsend.do"</span>; <span class="hljs-comment">//应用级消息下发API</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  String accessToken;<span class="hljs-comment">//下发通知消息的认证Token</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">long</span> tokenExpiredTime;  <span class="hljs-comment">//accessToken的过期时间</span>

   <span class="hljs-comment">//省略部分代码</span>

   …

    <span class="hljs-comment">//获取Access Token</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException
    </span>{
        String msgBody = MessageFormat.format(
         <span class="hljs-string">"grant_type=client_credentials&amp;client_secret={0}&amp;client_id={1}"</span>, 
         URLEncoder.encode(appSecret, <span class="hljs-string">"UTF-8"</span>), appId);
        String response = httpPost(tokenUrl, msgBody, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>);
        JSONObject obj = JSONObject.parseObject(response);
        accessToken = obj.getString(<span class="hljs-string">"access_token"</span>);
        tokenExpiredTime = System.currentTimeMillis() + (obj.getLong(<span class="hljs-string">"expires_in"</span>) - <span class="hljs-number">5</span>*<span class="hljs-number">60</span>)*<span class="hljs-number">1000</span>;
    }
} 
</div></code></pre>
<h3 id="22-%e5%ba%94%e7%94%a8%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81push%e6%b6%88%e6%81%af">2.2 应用服务器发送Push消息</h3>
<p>接口名：openpush.message.api.send，接口详细定义参见请求服务端发送PUSH消息。</p>
<p>通过上一章节客户端的开发，使用getToken接口获取到的PUSH Token已被保存到开发者自己的应用服务器了，接下来开发者可以在自己的服务器封装PUSH消息，通过调用服务端的openpush.message.api.send接口，给这些设备批量推送消息了。</p>
<p>此开发步骤主要指导开发者如何封装PUSH请求消息，对于“通知栏消息”和“透传消息”有不同的参数可选，本章节以“场景介绍”中的“点击PUSH消息打开指定APP”为例，其他场景的详细参数定义参见<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_s2">服务端发送PUSH接口</a>，里面提供了封装完成的消息样例供开发者参考。</p>
<blockquote>
<p>1.发送PUSH消息前判断AT是否过期，如果过期需要重新申请。其中refreshToken()为上一章节实现的获取AT的方法。</p>
</blockquote>
<pre><code class="language-java"><div><span class="hljs-keyword">if</span> (tokenExpiredTime &lt;= System.currentTimeMillis())        
    { 
        refreshToken();        
    }   
</div></code></pre>
<blockquote>
<p>2.封装PUSH Token，PUSH Token为客户端调用getToken()接口获取到保存到服务器的，开发者需要读取服务器上的token，将其放到JSONArray中。服务器接口每次只支持发送100个，如需更大发送量，请参考<a href="https://developer.huawei.com/consumer/cn/help/60103">放开流控限制</a>。</p>
</blockquote>
<pre><code class="language-java"><div><span class="hljs-comment">/*PushManager.requestToken为客户端申请token的方法，可以调用多次以防止申请token失败*/</span>
<span class="hljs-comment">/*PushToken不支持手动编写，需使用客户端的onToken方法获取*/</span>
JSONArray deviceTokens = <span class="hljs-keyword">new</span> JSONArray();<span class="hljs-comment">//目标设备Token</span>
deviceTokens.add(<span class="hljs-string">"12345678901234561234567890123456"</span>);
deviceTokens.add(<span class="hljs-string">"22345678901234561234567890123456"</span>);
deviceTokens.add(<span class="hljs-string">"32345678901234561234567890123456"</span>);
</div></code></pre>
<blockquote>
<p>3.封装推送消息body，用于显示通知栏消息显示的标题和内容</p>
</blockquote>
<pre><code class="language-java"><div>JSONObject body = <span class="hljs-keyword">new</span> JSONObject();<span class="hljs-comment">//仅通知栏消息需要设置标题和内容，透传消息key和value为用户自定义</span>
body.put(<span class="hljs-string">"title"</span>, <span class="hljs-string">"Push message title"</span>);<span class="hljs-comment">//消息标题</span>
body.put(<span class="hljs-string">"content"</span>, <span class="hljs-string">"Push message content"</span>);<span class="hljs-comment">//消息内容体</span>
</div></code></pre>
<blockquote>
<p>4.封装消息点击动作的参数，“com.huawei.hms.hmsdemo”为推送消息中需要打开的应用APK包名。请根据实际包名来修改。</p>
</blockquote>
<pre><code class="language-java"><div>JSONObject param = <span class="hljs-keyword">new</span> JSONObject();
param.put(<span class="hljs-string">"appPkgName"</span>, <span class="hljs-string">"com.huawei.hms.hmsdemo"</span>);<span class="hljs-comment">//定义需要打开的appPkgName</span>
</div></code></pre>
<blockquote>
<p>5.封装消息点击动作，用于定义通知栏点击行为，param为步骤4封装的点击动作参数</p>
</blockquote>
<pre><code class="language-java"><div>JSONObject action = <span class="hljs-keyword">new</span> JSONObject();
action.put(<span class="hljs-string">"type"</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//类型3为打开APP，其他行为请参考接口文档设置</span>
action.put(<span class="hljs-string">"param"</span>, param);<span class="hljs-comment">//消息点击动作参数</span>
</div></code></pre>
<blockquote>
<p>6.封装消息类型，用于定义消息类型，区分是通知栏消息还是透传消息，其中action和body分别是步骤5和步骤3封装的消息。</p>
</blockquote>
<pre><code class="language-java"><div>JSONObject msg = <span class="hljs-keyword">new</span> JSONObject();
msg.put(<span class="hljs-string">"type"</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//3: 通知栏消息，异步透传消息请根据接口文档设置</span>
msg.put(<span class="hljs-string">"action"</span>, action);<span class="hljs-comment">//消息点击动作</span>
msg.put(<span class="hljs-string">"body"</span>, body);<span class="hljs-comment">//通知栏消息body内容示例代码</span>
</div></code></pre>
<blockquote>
<p>7.封装扩展消息，扩展消息中可以设置biTag用于消息打点，也可以携带customize参数用于触发通知栏点击事件的onEvent回调。</p>
</blockquote>
<pre><code class="language-java"><div>JSONObject ext = <span class="hljs-keyword">new</span> JSONObject();<span class="hljs-comment">//扩展信息，含BI消息统计，特定展示风格，消息折叠。</span>
ext.put(<span class="hljs-string">"biTag"</span>, <span class="hljs-string">"Trump"</span>);<span class="hljs-comment">//设置消息标签，如果带了这个标签，会在回执中推送给CP用于检测某种类型消息的到达率和状态</span>

JSONObject temp= <span class="hljs-keyword">new</span> JSONObject();
temp.put(<span class="hljs-string">"season"</span>,<span class="hljs-string">"Spring"</span>);
temp.put(<span class="hljs-string">"weather"</span>,<span class="hljs-string">"raining"</span>);
JSONArray customize = <span class="hljs-keyword">new</span> JSONArray();  
customize.add(temp);
ext.put(<span class="hljs-string">"customize"</span>,customize);
</div></code></pre>
<blockquote>
<p>8.封装整个消息体，可自定义实现单击消息后的跳转动作。封装完整的消息体请参考<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_s2#3%20%E5%8F%82%E6%95%B0">“payload消息体样例”</a>。</p>
</blockquote>
<pre><code class="language-java"><div>JSONObject hps = <span class="hljs-keyword">new</span> JSONObject();<span class="hljs-comment">//华为PUSH消息总结构体</span>
hps.put(<span class="hljs-string">"msg"</span>, msg);
hps.put(<span class="hljs-string">"ext"</span>, ext);

JSONObject payload = <span class="hljs-keyword">new</span> JSONObject();
payload.put(<span class="hljs-string">"hps"</span>, hps);
</div></code></pre>
<blockquote>
<p>9.定义httpPost()方法，用于消息发送。</p>
</blockquote>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">httpPost</span><span class="hljs-params">(String httpUrl, String data, <span class="hljs-keyword">int</span> connectTimeout, <span class="hljs-keyword">int</span> readTimeout)</span> <span class="hljs-keyword">throws</span> IOException
    </span>{
        OutputStream outPut = <span class="hljs-keyword">null</span>;
        HttpURLConnection urlConnection = <span class="hljs-keyword">null</span>;
        InputStream in = <span class="hljs-keyword">null</span>;
        
        <span class="hljs-keyword">try</span>
        {
            URL url = <span class="hljs-keyword">new</span> URL(httpUrl);
            urlConnection = (HttpURLConnection)url.openConnection();          
            urlConnection.setRequestMethod(<span class="hljs-string">"POST"</span>);
            urlConnection.setDoOutput(<span class="hljs-keyword">true</span>);
            urlConnection.setDoInput(<span class="hljs-keyword">true</span>);
            urlConnection.setRequestProperty(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/x-www-form-urlencoded; charset=UTF-8"</span>);
            urlConnection.setConnectTimeout(connectTimeout);
            urlConnection.setReadTimeout(readTimeout);
            urlConnection.connect();
            
            <span class="hljs-comment">// POST data</span>
            outPut = urlConnection.getOutputStream();
            outPut.write(data.getBytes(<span class="hljs-string">"UTF-8"</span>));
            outPut.flush();
            
            <span class="hljs-comment">// read response</span>
            <span class="hljs-keyword">if</span> (urlConnection.getResponseCode() &lt; <span class="hljs-number">400</span>)
            {
                in = urlConnection.getInputStream();
            }
            <span class="hljs-keyword">else</span>
            {
                in = urlConnection.getErrorStream();
            }
            
            List&lt;String&gt; lines = IOUtils.readLines(in, urlConnection.getContentEncoding());
            StringBuffer strBuf = <span class="hljs-keyword">new</span> StringBuffer();
            <span class="hljs-keyword">for</span> (String line : lines)
            {
                strBuf.append(line);
            }
            System.out.println(strBuf.toString());
            <span class="hljs-keyword">return</span> strBuf.toString();
        }
        <span class="hljs-keyword">finally</span>
        {
            IOUtils.closeQuietly(outPut);
            IOUtils.closeQuietly(in);
            <span class="hljs-keyword">if</span> (urlConnection != <span class="hljs-keyword">null</span>)
            {
                urlConnection.disconnect();
            }
        }
    }
</div></code></pre>
<blockquote>
<p>10.封装整个http消息并发送</p>
</blockquote>
<pre><code class="language-java"><div>String postBody = MessageFormat.format(
         <span class="hljs-string">"access_token={0}&amp;nsp_svc={1}&amp;nsp_ts={2}&amp;device_token_list={3}&amp;payload={4}"</span>,
            URLEncoder.encode(accessToken,<span class="hljs-string">"UTF-8"</span>),
            URLEncoder.encode(<span class="hljs-string">"openpush.message.api.send"</span>,<span class="hljs-string">"UTF-8"</span>),
            URLEncoder.encode(String.valueOf(System.currentTimeMillis() / <span class="hljs-number">1000</span>),<span class="hljs-string">"UTF-8"</span>),
            URLEncoder.encode(deviceTokens.toString(),<span class="hljs-string">"UTF-8"</span>),
            URLEncoder.encode(payload.toString(),<span class="hljs-string">"UTF-8"</span>));

String postUrl = apiUrl + <span class="hljs-string">"?nsp_ctx="</span> + URLEncoder.encode(<span class="hljs-string">"{\"ver\":\"1\", \"appId\":\""</span> + appId + <span class="hljs-string">"\"}"</span>, <span class="hljs-string">"UTF-8"</span>);
httpPost(postUrl, postBody, <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>);    <span class="hljs-comment">//发送PUSH消息</span>
</div></code></pre>
<blockquote>
<p>11.透传消息相对于通知栏消息的请求参数封装少了很多，开发者只需要完成上面的步骤1、2、3、6、8、9、10</p>
</blockquote>
<p>其中步骤3中对于透传消息不需要封装title和content只需要封装自定义的body内容。</p>
<p>封装透传消息的body</p>
<pre><code class="language-java"><div>JSONObject body = <span class="hljs-keyword">new</span> JSONObject();
body.put(<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>);<span class="hljs-comment">//透传消息自定义body内容</span>
body.put(<span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>);<span class="hljs-comment">//透传消息自定义body内容</span>
body.put(<span class="hljs-string">"key3"</span>, <span class="hljs-string">"value3"</span>);<span class="hljs-comment">//透传消息自定义body内容</span>
</div></code></pre>
<h3 id="23-%e9%80%9a%e8%bf%87%e6%b6%88%e6%81%af%e5%9b%9e%e6%89%a7%e5%ae%9e%e7%8e%b0%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%a8%e9%80%81%e5%8f%af%e9%80%89">2.3 通过消息回执实现自定义推送（可选）</h3>
<p>{% asset_img hms1.png %}</p>
<p>本章节介绍如何根据消息回执的状态，来给特定用户发送消息。开发者需先在开发者联盟为应用<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_devprepare_agent#3%20%E5%BC%80%E9%80%9A%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1">开通消息回执</a>。</p>
<p>消息回执是华为PUSH服务器提供的对应用服务器消息推送结果的通知。</p>
<p>例如，某开发者开发了一个APP，该APP的安装用户有100个。使用华为PUSH后，在开发者的服务器侧有100个对应PUSH Token，如果这100个用户中的10个用户已经将该APP卸载了，对于开发者是无法感知的，如果开发者还向这10个用户发送消息会存在问题，如图所描述，在回执消息中会将状态为2的消息应答状态回执给开发者。这样开发者就知道这10个用户已经卸载应用了，开发者可以不给这些应用发送消息。</p>
<p>消息回执由华为PUSH服务器发往开发者服务器，开发者需自行实现接口接收华为PUSH服务器发送的回执消息，回执接口详细定义参见<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_s3">消息回执API</a>。</p>
<h3 id="24-%e6%9c%8d%e5%8a%a1%e7%ab%af%e5%8f%91%e9%80%81%e5%ba%94%e7%94%a8%e8%a7%92%e6%a0%87%e5%8f%af%e9%80%89">2.4 服务端发送应用角标（可选）</h3>
<p>开发者可以在PUSH消息中封装角标参数来发送给客户端展示对应的角标数量。</p>
<p>服务端发送PUSH角标需要在PUSH接口的Payload的ext中增加badgeAddNum、badgeClass配置参数，其他参数配置同正常的消息发送接口，消息封装方法参考<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_devguide_server_agent#3%20%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81Push%E6%B6%88%E6%81%AF">“应用服务器发送PUSH消息”</a>，接口详细参数定义参见<a href="https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page=hmssdk_huaweipush_api_reference_agent_s2">服务端发送PUSH接口</a>。</p>
<pre><code class="language-json"><div>{                            
    <span class="hljs-attr">"hps"</span>: {                                         
        <span class="hljs-attr">"msg"</span> : {                                        
            <span class="hljs-attr">"type"</span> : <span class="hljs-number">3</span>,                                        
            <span class="hljs-attr">"body"</span> : {                                        
                <span class="hljs-attr">"content"</span> : <span class="hljs-string">"Push message content"</span>, 
                <span class="hljs-attr">"title"</span> : <span class="hljs-string">"Push message content"</span>                            
                },                                         
            <span class="hljs-attr">"action"</span> : {                                        
                <span class="hljs-attr">"type"</span> : <span class="hljs-number">1</span>,                                        
                <span class="hljs-attr">"param"</span> : {                                        
                    <span class="hljs-attr">"intent"</span>:<span class="hljs-string">"#Intent;compo=com.rvr/.Activity;S.W=U;end"</span>
                }                                        
            }                        
        },                                        
       <span class="hljs-attr">"ext"</span> : {                                        
            <span class="hljs-attr">"badgeAddNum"</span> : <span class="hljs-string">"1"</span>,
            <span class="hljs-attr">"badgeClass"</span> : <span class="hljs-string">"com.test.badge.MainActivity"</span>
        }                                        
    }
}   
</div></code></pre>
<ul>
<li>
<p>badgeAddNum：角标数字，取值范围1-99</p>
</li>
<li>
<p>badgeClass：桌面图标对应的应用入口Activity类</p>
</li>
</ul>
<h3 id="25-%e6%b5%8b%e8%af%95">2.5 测试</h3>
<p>至此开发者已完成所有客户端和服务端的开发工作，下一步可以通过调用应用服务器的接口测试PUSH消息能否正确的送达客户端。</p>
<h2 id="%e5%b0%8f%e7%b1%b3%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1">小米推送服务</h2>
<h3 id="%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c">准备工作</h3>
<blockquote>
<p>1.登录小米开发者网站，创建App并获取AppId，AppKey和AppSecret。</p>
</blockquote>
<p>在使用小米推送服务前，开发者需要先登录小米开发者网站（<a href="https://dev.mi.com/console/">https://dev.mi.com/console/</a> ）创建App，在更多服务中查看AppId，AppKey和AppSecret（详细介绍请参见<a href="https://dev.mi.com/console/doc/detail?pId=68">《小米推送服务启用指南》</a>）。其中AppId和AppKey是客户端的身份标识，在客户端SDK初始化时使用；AppSecret是服务器端的身份标识，在使用Server SDK向客户端发送消息时使用。</p>
<blockquote>
<p>2.下载Android客户端SDK压缩包。</p>
</blockquote>
<p>下载地址：<a href="http://dev.xiaomi.com/mipush/downpage/">http://dev.xiaomi.com/mipush/downpage/</a> 。</p>
<p>压缩包中包含了Server SDK、Client SDK和android DEMO。</p>
<p>Android的SDK以jar形式提供，与华为推送类似，客户端在注册成功后，会得到服务器颁发的regId，之后可以通过订阅topic、设置alias等方式来接收推送消息。小米推送目前也支持两种消息传递方式：透传方式和通知栏方式。消息传到客户端后同样是通过广播的形式传递的。</p>
<blockquote>
<p>3.配置AndroidManifest.xml文件</p>
</blockquote>
<p>小米推送服务SDK支持的最低安卓版本为2.3。对应android:minSdkVersion = 9</p>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!-- 权限 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span>​

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /&gt;</span> 

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span> 

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span> 

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.GET_TASKS"</span> /&gt;</span> 

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.VIBRATE"</span>/&gt;</span> 

<span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.xiaomi.mipushdemo.permission.MIPUSH_RECEIVE"</span>
<span class="hljs-attr">android:protectionLevel</span>=<span class="hljs-string">"signature"</span> /&gt;</span> <span class="hljs-comment">&lt;!--这里com.xiaomi.mipushdemo改成app的包名--&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.xiaomi.mipushdemo.permission.MIPUSH_RECEIVE"</span> /&gt;</span><span class="hljs-comment">&lt;!--这里com.xiaomi.mipushdemo改成app的包名--&gt;</span>
</div></code></pre>
<p>推送服务需要配置的service和receiver：</p>
<pre><code class="language-java"><div>&lt;service android:enabled=<span class="hljs-string">"true"</span> android:process=<span class="hljs-string">":pushservice"</span> android:name=<span class="hljs-string">"com.xiaomi.push.service.XMPushService"</span>/&gt; 

&lt;service android:name=<span class="hljs-string">"com.xiaomi.push.service.XMJobService"</span> android:enabled=<span class="hljs-string">"true"</span> android:exported=<span class="hljs-string">"false"</span> android:permission=<span class="hljs-string">"android.permission.BIND_JOB_SERVICE"</span> android:process=<span class="hljs-string">":pushservice"</span> /&gt; &lt;!--注：此service必须在<span class="hljs-number">3.0</span>.1版本以后（包括<span class="hljs-number">3.0</span>.1版本）加入--&gt; 

&lt;service android:enabled=<span class="hljs-string">"true"</span> android:exported=<span class="hljs-string">"true"</span> android:name=<span class="hljs-string">"com.xiaomi.mipush.sdk.PushMessageHandler"</span> /&gt; 

&lt;service android:enabled=<span class="hljs-string">"true"</span> android:name=<span class="hljs-string">"com.xiaomi.mipush.sdk.MessageHandleService"</span> /&gt; &lt;!--注：此service必须在<span class="hljs-number">2.2</span>.5版本以后（包括<span class="hljs-number">2.2</span>.5版本）加入--&gt; &lt;receiver android:exported=<span class="hljs-string">"true"</span> android:name=<span class="hljs-string">"com.xiaomi.push.service.receivers.NetworkStatusReceiver"</span> &gt; 

&lt;intent-filter&gt; 

&lt;action android:name=<span class="hljs-string">"android.net.conn.CONNECTIVITY_CHANGE"</span> /&gt; 

&lt;category android:name=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt; 

&lt;/intent-filter&gt; 

&lt;/receiver&gt; 

&lt;receiver android:exported=<span class="hljs-string">"false"</span> android:process=<span class="hljs-string">":pushservice"</span> android:name=<span class="hljs-string">"com.xiaomi.push.service.receivers.PingReceiver"</span> &gt; 

&lt;intent-filter&gt; 

&lt;action android:name=<span class="hljs-string">"com.xiaomi.push.PING_TIMER"</span> /&gt; 

&lt;/intent-filter&gt; 

&lt;/receiver&gt;
</div></code></pre>
<p>这里将XMPushService和PingReceiver定义在了pushservice进程中，您也可以配置其运行在任意进程。如果没有配置android:process这个属性，那么它们将运行在应用的主进程中。</p>
<blockquote>
<p>4.自定义一个BroadcastReceiver类</p>
</blockquote>
<p>为了接收消息，您需要自定义一个继承自PushMessageReceiver类的BroadcastReceiver，实现其中的onReceivePassThroughMessage，onNotificationMessageClicked，onNotificationMessageArrived，onCommandResult和onReceiveRegisterResult方法，然后把该receiver注册到AndroidManifest.xml文件中。onReceivePassThroughMessage用来接收服务器发送的透传消息，onNotificationMessageClicked用来接收服务器发来的通知栏消息（用户点击通知栏时触发），onNotificationMessageArrived用来接收服务器发来的通知栏消息（消息到达客户端时触发，并且可以接收应用在前台时不弹出通知的通知消息），onCommandResult用来接收客户端向服务器发送命令消息后返回的响应，onReceiveRegisterResult用来接受客户端向服务器发送注册命令消息后返回的响应。 例如： 自定义的BroadcastReceiver</p>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoMessageReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PushMessageReceiver</span> </span>{
    <span class="hljs-keyword">private</span> String mRegId;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> mResultCode = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">private</span> String mReason;
    <span class="hljs-keyword">private</span> String mCommand;
    <span class="hljs-keyword">private</span> String mMessage;
    <span class="hljs-keyword">private</span> String mTopic;
    <span class="hljs-keyword">private</span> String mAlias;
    <span class="hljs-keyword">private</span> String mUserAccount;
    <span class="hljs-keyword">private</span> String mStartTime;
    <span class="hljs-keyword">private</span> String mEndTime;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivePassThroughMessage</span><span class="hljs-params">(Context context, MiPushMessage message)</span> </span>{
        mMessage = message.getContent();
        <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getTopic())) {
            mTopic=message.getTopic();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getAlias())) {
            mAlias=message.getAlias();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getUserAccount())) {
            mUserAccount=message.getUserAccount();
        }
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationMessageClicked</span><span class="hljs-params">(Context context, MiPushMessage message)</span> </span>{
        mMessage = message.getContent();
        <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getTopic())) {
            mTopic=message.getTopic();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getAlias())) {
            mAlias=message.getAlias();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getUserAccount())) {
            mUserAccount=message.getUserAccount();
        }
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationMessageArrived</span><span class="hljs-params">(Context context, MiPushMessage message)</span> </span>{
        mMessage = message.getContent();
        <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getTopic())) {
            mTopic=message.getTopic();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getAlias())) {
            mAlias=message.getAlias();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getUserAccount())) {
            mUserAccount=message.getUserAccount();
        }
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCommandResult</span><span class="hljs-params">(Context context, MiPushCommandMessage message)</span> </span>{
        String command = message.getCommand();
        List&lt;String&gt; arguments = message.getCommandArguments();
        String cmdArg1 = ((arguments != <span class="hljs-keyword">null</span> &amp;&amp; arguments.size() &gt; <span class="hljs-number">0</span>) ? arguments.get(<span class="hljs-number">0</span>) : <span class="hljs-keyword">null</span>);
        String cmdArg2 = ((arguments != <span class="hljs-keyword">null</span> &amp;&amp; arguments.size() &gt; <span class="hljs-number">1</span>) ? arguments.get(<span class="hljs-number">1</span>) : <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_REGISTER.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mRegId = cmdArg1;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_SET_ALIAS.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mAlias = cmdArg1;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_UNSET_ALIAS.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mAlias = cmdArg1;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_SUBSCRIBE_TOPIC.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mTopic = cmdArg1;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_UNSUBSCRIBE_TOPIC.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mTopic = cmdArg1;
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_SET_ACCEPT_TIME.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mStartTime = cmdArg1;
                mEndTime = cmdArg2;
            }
        } 
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceiveRegisterResult</span><span class="hljs-params">(Context context, MiPushCommandMessage message)</span> </span>{
        String command = message.getCommand();
        List&lt;String&gt; arguments = message.getCommandArguments();
        String cmdArg1 = ((arguments != <span class="hljs-keyword">null</span> &amp;&amp; arguments.size() &gt; <span class="hljs-number">0</span>) ? arguments.get(<span class="hljs-number">0</span>) : <span class="hljs-keyword">null</span>);
        String cmdArg2 = ((arguments != <span class="hljs-keyword">null</span> &amp;&amp; arguments.size() &gt; <span class="hljs-number">1</span>) ? arguments.get(<span class="hljs-number">1</span>) : <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">if</span> (MiPushClient.COMMAND_REGISTER.equals(command)) {
            <span class="hljs-keyword">if</span> (message.getResultCode() == ErrorCode.SUCCESS) {
                mRegId = cmdArg1;
            }
        } 
    }
}
</div></code></pre>
<p>将自定义的BroadcastReceiver注册到AndroidManifest.xml文件中</p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span>
  <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.xiaomi.mipushdemo.DemoMessageReceiver"</span>&gt;</span>
          <span class="hljs-comment">&lt;!--这里com.xiaomi.mipushdemo.DemoMessageRreceiver改成app中定义的完整类名--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.xiaomi.mipush.RECEIVE_MESSAGE"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.xiaomi.mipush.MESSAGE_ARRIVED"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.xiaomi.mipush.ERROR"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>
</div></code></pre>
<p>注意：</p>
<p>上述方法运行在非UI线程中。
如果你的应用使用了混淆，你需要keep自定义的BroadcastReceiver。自定义的BroadcastReceiver继承PushMessageReceiver，使用下面的代码是不行的:</p>
<p><code>-keep public class * extends android.content.BroadcastReceiver</code></p>
<p>你需要使用下面的代码keep自定义的BroadcastReceiver。#这里com.xiaomi.mipushdemo.DemoMessageRreceiver改成app中定义的完整类名</p>
<p><code>-keep class com.xiaomi.mipush.sdk.DemoMessageReceiver {*;}</code></p>
<blockquote>
<p>5.调试日志</p>
</blockquote>
<p>在自定义Application的onCreate方法加入如下代码。</p>
<pre><code class="language-java"><div>LoggerInterface newLogger = <span class="hljs-keyword">new</span> LoggerInterface() {
     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTag</span><span class="hljs-params">(String tag)</span> </span>{
         <span class="hljs-comment">// ignore</span>
     }
     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String content, Throwable t)</span> </span>{
         Log.d(TAG, content, t);
     }
     <span class="hljs-meta">@Override</span>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String content)</span> </span>{
         Log.d(TAG, content);
     }
};
Logger.setLogger(<span class="hljs-keyword">this</span>, newLogger);
</div></code></pre>
<p>注：默认情况下，我们会将日志内容写入SDCard/Android/data/app pkgname/files/MiPushLog目录下的文件。如果app需要关闭写日志文件功能（不建议关闭），只需要调用Logger.disablePushFileLog(context)即可。</p>
<blockquote>
<p>6.注册推送服务</p>
</blockquote>
<p>通过调用MiPushClient.registerPush来初始化小米推送服务。注册成功后，您可以在自定义的onCommandResult和onReceiveRegisterResult中收到注册结果，其中的regId即是当前设备上当前app的唯一标示。您可以将regId上传到自己的服务器，方便向其发消息。</p>
<p>为了提高push的注册率，您可以在Application的onCreate中初始化push。您也可以根据需要，在其他地方初始化push。 代码如下：</p>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Application</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String APP_ID = <span class="hljs-string">"your appid"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String APP_KEY = <span class="hljs-string">"your appkey"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"your packagename"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.onCreate();
        <span class="hljs-comment">//初始化push推送服务</span>
        <span class="hljs-keyword">if</span>(shouldInit()) {
            MiPushClient.registerPush(<span class="hljs-keyword">this</span>, APP_ID, APP_KEY);
        }
        <span class="hljs-comment">//打开Log</span>
        LoggerInterface newLogger = <span class="hljs-keyword">new</span> LoggerInterface() {

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTag</span><span class="hljs-params">(String tag)</span> </span>{
                <span class="hljs-comment">// ignore   </span>
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String content, Throwable t)</span> </span>{
                Log.d(TAG, content, t);
            }

            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String content)</span> </span>{
                Log.d(TAG, content);
            }
        };
        Logger.setLogger(<span class="hljs-keyword">this</span>, newLogger);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldInit</span><span class="hljs-params">()</span> </span>{
        ActivityManager am = ((ActivityManager) getSystemService(Context.ACTIVITY_SERVICE));
        List&lt;RunningAppProcessInfo&gt; processInfos = am.getRunningAppProcesses();
        String mainProcessName = getApplicationInfo().processName();
        <span class="hljs-keyword">int</span> myPid = Process.myPid();
        <span class="hljs-keyword">for</span> (RunningAppProcessInfo info : processInfos) {
            <span class="hljs-keyword">if</span> (info.pid == myPid &amp;&amp; mainProcessName.equals(info.processName)) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}
</div></code></pre>
<p>注意：</p>
<ul>
<li>因为推送服务XMPushService在AndroidManifest.xml中设置为运行在另外一个进程，这导致本Application会被实例化两次，所以我们需要让应用的主进程初始化。</li>
<li>在非MIUI平台下，如果targetSdkVersion&gt;=23，需要动态申请电话和存储权限，请在申请权限后再调用注册接口，否则会注册失败。</li>
</ul>
<blockquote>
<p>7.设置alias、userAccount和订阅topic</p>
</blockquote>
<p>在注册成功，收到regId之后，即可调用MiPushClient.setAlias来设置alias，调MiPushClient.setUserAccount来设置userAccount，调MiPushClient.subscribe订阅topic。 alias可以理解为regId的别名，开发者可以将alias设置为自己应用帐号系统的帐号，或者设备标识等。然后在使用Server SDK发送消息的时候，即可直接指定发送给特定的alias，而不是regId，避免存储regId。 开发者可以在不同设备上设置同一个userAccount。然后使用Server SDK给该userAccount发送消息；此时，所有设置了该userAccount的设备都可以收到消息。 主题用来做广播消息。不同手机上的同一个app可以订阅同一个主题。通过发送主题消息的API，即可同时向所有订阅该主题的客户端发送消息。比如，您有一个新闻类的app，可以自定义“财经”、“体育”、“科技“等主题；对于经常阅读财经新闻的用户，您可以帮用户订阅“财经”类主题，当有新的财经要闻发生时，直接通过主题推送该新闻给所有订阅该主题的用户。</p>
<blockquote>
<p>8.通知消息处理</p>
</blockquote>
<p>目前通知类的消息， 通知的图标展示规则如下：</p>
<ul>
<li>如果app中同时存在名为mipush_notification和mipush_small_notification的drawable文件，则使用mipush_notification的drawable作为通知的大图标，mipush_small_notification的drawable作为通知的小图标。</li>
<li>如果app中只存在其中一个drawable文件，则使用该drawable作为通知的图标。</li>
<li>如果app中不存在这两个drawable文件，则使用app的icon作为通知的图标。在MIUI中，通知栏图标统一显示为app的icon，不可以定制。</li>
</ul>
<p>通知消息分为自定义通知消息和预定义通知消息。 如果服务端调用Message.Builder类的extra(String key, String value)方法设置了Constants.EXTRA_PARAM_NOTIFY_EFFECT的值，则为预定义通知消息（具体细节请参见<a href="https://dev.mi.com/console/doc/detail?pId=1278#_3_2">《服务端Java SDK文档》</a>）；否则为自定义通知消息。 如果在小米推送服务开发者站推送消息，需要通过指定“点击后续动作”来指定通知消息类型。 通知消息到达客户端后会在通知栏弹出notification，这时候消息已经传到PushMessageReceiver继承类的onNotificationMessageArrived方法，但这时候消息还没有通过PushMessageReceiver继承类的的onNotificationMessageClicked方法传到客户端。当用户点击了自定义通知消息，消息会通过onNotificationMessageClicked方法传到客户端。</p>
<p><strong>注意：用户点击了预定义通知消息，消息不会通过onNotificationMessageClicked方法传到客户端。</strong></p>
<blockquote>
<p>9.客户端定义不同的通知栏消息点击行为，分为以下四种</p>
</blockquote>
<ul>
<li>1.自定义通知消息的处理</li>
</ul>
<p>服务端没有设置Constants.EXTRA_PARAM_NOTIFY_EFFECT的值表示是自定义通知消息。客户端收到自定义通知消息后，可以自定义一些操作。 比如：通过启动一个Activity将消息传过去，这时需要给Intent添加FLAG_ACTIVITY_NEW_TASK。</p>
<pre><code class="language-java"><div>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</div></code></pre>
<p>透传消息和自定义通知消息的处理参考代码如下：</p>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivePassThroughMessage</span><span class="hljs-params">(Context context, MiPushMessage message)</span>
</span>{ 
  mMessage = message.getContent(); 
  <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getTopic())) { 
    mTopic=message.getTopic(); 
 } 
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getAlias())) {
  mAlias=message.getAlias(); 
 } 
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationMessageClicked</span><span class="hljs-params">(Context context, MiPushMessage message)</span> 
</span>{ 
  mMessage = message.getContent(); 
  <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getTopic())) {
   mTopic=message.getTopic(); 
  } 
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getAlias())) { 
    mAlias=message.getAlias(); 
  }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationMessageArrived</span><span class="hljs-params">(Context context, MiPushMessage message)</span> 
</span>{ 
  mMessage = message.getContent(); 
  <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getTopic())) {
    mTopic=message.getTopic(); 
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!TextUtils.isEmpty(message.getAlias())) {
    mAlias=message.getAlias(); 
  } 
}
</div></code></pre>
<ul>
<li>2.打开当前app对应的Launcher Activity</li>
</ul>
<p>服务端调用Message.Builder类的extra(String key, String value)方法，将key设置为Constants.EXTRA_PARAM_NOTIFY_EFFECT，value设置为Constants.NOTIFY_LAUNCHER_ACTIVITY。具体请参见<a href="https://dev.mi.com/console/doc/detail?pId=1278#_3_2">《服务端Java SDK文档》</a>。封装消息的MiPushMessage对象通过Intent传到客户端，客户端在相应的Activity中可以调用Intent的getSerializableExtra（PushMessageHelper.KEY_MESSAGE）方法得到MiPushMessage对象。</p>
<ul>
<li>3.打开当前app内的任意一个Activity</li>
</ul>
<p>服务端调用Message.Builder类的extra(String key, String value)方法，将key设置为Constants.EXTRA_PARAM_NOTIFY_EFFECT，value设置为Constants.NOTIFY_ACTIVITY。具体请参见<a href="https://dev.mi.com/console/doc/detail?pId=1278#_3_2">《服务端Java SDK文档》</a>。封装消息的MiPushMessage对象通过Intent传到客户端，客户端在相应的Activity中可以调用Intent的getSerializableExtra（PushMessageHelper.KEY_MESSAGE）方法得到MiPushMessage对象。</p>
<ul>
<li>4.打开网页</li>
</ul>
<p>服务端调用Message.Builder类的extra(String key, String value)方法，将key设置为Constants.EXTRA_PARAM_NOTIFY_EFFECT，value设置为Constants.NOTIFY_WEB。具体请参见<a href="https://dev.mi.com/console/doc/detail?pId=1278#_3_2">《服务端Java SDK文档》</a>。</p>
<blockquote>
<p>10.自定义通知栏</p>
</blockquote>
<p>服务端在发送消息时可以自定义通知栏效果</p>
<ul>
<li>1.自定义通知栏消息铃声</li>
</ul>
<p>服务端发送消息时调用Message.Builder类的extra(String key, String value)方法将key设置为Constants.EXTRA_PARAM_SOUND_URI，value设置为铃声的URI。 注：</p>
<ul>
<li>铃声只能使用当前app内的资源，URI格式满足 android.resource://your packagename/XXX/XXX。</li>
<li>铃声文件放在Android app的raw目录下。</li>
</ul>
<p>Demo：</p>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">private</span> Message <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
     String PACKAGENAME = <span class="hljs-string">"com.xiaomi.mipushdemo"</span>;
     String messagePayload = “This is a message”;
     String title = “notification title”;
     String description = “notification description”;
     Message message = <span class="hljs-keyword">new</span> Message.Builder()
             .title(title)
             .description(description).payload(messagePayload)
             .restrictedPackageName(MY_PACKAGE_NAME)
             .passThrough(<span class="hljs-number">0</span>)  <span class="hljs-comment">//消息使用通知栏方式</span>
             .notifyType(<span class="hljs-number">1</span>)
             .extra(Constants.EXTRA_PARAM_SOUND_URI, <span class="hljs-string">"android.resource://"</span> + PACKAGENAME + <span class="hljs-string">"/raw/shaking"</span>)
             .build();
     <span class="hljs-keyword">return</span> message;
}
</div></code></pre>
<ul>
<li>2.自定义通知栏样式</li>
</ul>
<p>如果系统默认的通知栏样式不满足需求，开发者可以自定义通知栏样式。服务端推送消息通过指定layout文件和填充内容，自由定制展示样式。 注意，在MIUI中，通知展示由系统通道负责，需要MIUI升级后才支持自定义通知。 具体使用方法如下：</p>
<ol>
<li>layout文件中只能包含以下控件: FrameLayout, LinearLayout, RelativeLayout, Button, ImageButton, ImageView, ProgressBar, TextView；</li>
<li>调用Message.Builder类的extra(String key, String value)方法将以“layout_name”为key，value设置为客户端要展示的layout文件名；</li>
<li>以“layout_value”为key，指定layout中各控件展示的内容，其value为一个Json。其格式为{“text”:{“txt_res_name1”:”txt_value1”, “txt_res_name2”:”txt_value2”…}, “image”:{“img_res_name1”:”img_value1”, “img_res_name2”:”img_value2”…}, “time”:{“time_res_name”:”format_value”}}。</li>
</ol>
<p>其中：txt_res_name为layout文件中的控件名字，txt_value为控件上需要展示的文本内容。 img_res_name为layout中需要展示图片资源的控件名字，img_value为程序中对应的资源名。 time_res_name为layout文件中的控件名字，format_value为控件上需要展示的时间format样式。默认 yy-MM-dd hh:mm。 Demo: 以下消息，将指定以custom_notify为通知栏样式，将其中的titleText设置为“我是标题”，descText设置为“我是描述”；将iconImage设置为icon对应的图片。</p>
<pre><code class="language-java"><div><span class="hljs-function"><span class="hljs-keyword">private</span> Message <span class="hljs-title">buildMessage</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
     String PACKAGENAME = <span class="hljs-string">"com.xiaomi.mipushdemo"</span>;
     String messagePayload = “This is a message”;
     String title = “notification title”;
     String description = “notification description”;
     Message message = <span class="hljs-keyword">new</span> Message.Builder()
             .title(title)
             .description(description).payload(messagePayload)
             .restrictedPackageName(MY_PACKAGE_NAME)
             .passThrough(<span class="hljs-number">0</span>)  <span class="hljs-comment">//消息使用通知栏方式</span>
             .notifyType(<span class="hljs-number">1</span>)
             .extra(<span class="hljs-string">"layout_name"</span>,<span class="hljs-string">"custom_notify"</span>)
             .extra(<span class="hljs-string">"layout_value"</span>, <span class="hljs-string">"{\"text\":{\"titleText\":\"标题\"},\"image\": {\"iconImage\": \"icon\"},
                                      \"time\": {\"timeText\": \"HH:mm\"}}"</span>)​
             .build();
     <span class="hljs-keyword">return</span> message;
}
</div></code></pre>
<blockquote>
<p>11.Proguard 配置</p>
</blockquote>
<p>如果使用了 proguard，需要在配置文件中加入：</p>
<pre><code class="language-pro"><div>#这里com.xiaomi.mipushdemo.DemoMessageRreceiver改成app中定义的完整类名
-keep class com.xiaomi.mipush.sdk.DemoMessageReceiver {*;}
#可以防止一个误报的 warning 导致无法成功编译，如果编译使用的 Android 版本是 23。
-dontwarn com.xiaomi.push.**
</div></code></pre>
<h2 id="oppo%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1">OPPO推送服务</h2>
<p>OPPO推送服务文档与小米文档几乎类似，同样需要开通账号，申请PUSH服务，获得AppId、AppKey、AppSecret等验证信息。下载最新的SDK压缩包，其中包括了Server SDK、Client SDK、Android Demo。</p>
<p>Android的SDK以jar和aar形式提供，第三方APP只需要添加少量代码即可接入OPPO推送服务；</p>
<p>推送服务客户端SDK主要功能接口请参考详细API说明；</p>
<p>客户端在注册成功后，会得到服务器颁发的RegId，然后可以通过订阅Topic、设置Alias来接收推送消息。</p>
<h3 id="1-%e6%b7%bb%e5%8a%a0%e8%b5%84%e6%ba%90%e5%92%8c%e4%be%9d%e8%b5%96">1. 添加资源和依赖</h3>
<ul>
<li>
<p>解压缩集成压缩包；</p>
</li>
<li>
<p>复制com.coloros.mcssdk.jar到工程 libs/ 目录下；</p>
</li>
<li>
<p>在IDE中导入对jar的依赖,不同IDE稍有区别；</p>
</li>
<li>
<p>Eclipse:直接将jar包复制到工程 libs/目录下即可自动依赖；</p>
</li>
<li>
<p>Android Studio:需要在工程的build.gradle文件中添加如下配置代码：</p>
</li>
</ul>
<pre><code class="language-xml"><div>dependencies {
    ...
    compile fileTree(dir: 'libs', include: ['opush_xxx.jarcom.coloros.mcssdk.jar']) //添加opush jar
</div></code></pre>
<h3 id="2-%e9%85%8d%e7%bd%aeandroidmanifestxml">2. 配置AndroidManifest.xml</h3>
<p>OPPO推送服务SDK支持的最低安卓版本为Android 4.0系统。</p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">uses-sdk</span>  <span class="hljs-attr">android:minSdkVersion</span>=<span class="hljs-string">"14"</span>/&gt;</span>
</div></code></pre>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!-- 权限 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.coloros.mcs.permission.RECIEVE_MCS_MESSAGE"</span>/&gt;</span>
</div></code></pre>
<p>推送服务组件注册</p>
<pre><code class="language-xml"><div><span class="hljs-tag">&lt;<span class="hljs-name">service</span>
   <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.coloros.mcssdk.PushService"</span>     <span class="hljs-attr">android:permission</span>=<span class="hljs-string">"com.coloros.mcs.permission.SEND_MCS_MESSAGE"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.coloros.mcs.action.RECEIVE_MCS_MESSAGE"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span>
</div></code></pre>
<h3 id="3-%e6%b3%a8%e5%86%8c%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1">3. 注册推送服务</h3>
<p>1)由于不是所有平台都支持OPPO PUSH，提供接口PushManager.isSupportPush(Context)方便应用判断是否支持，支持才能继续后续操作，否则后续操作会抛出异常。</p>
<p>2)通过调用PushManager.getInstance().register(...)来初始化Opush推送服务.注册成功后,您可以在PushCallback的onRegister回调方法中得到regId,您可以将regId上传到自己的服务器，方便向其发消息。初始化相关参数具体要求参考详细API说明中的初始化部分.此接口会抛出异常，需要应用捕获处理。</p>
<p>3)为了提高push的注册率，你可以在Application的onCreate中初始化push。你也可以根据需要，在其他地方初始化push。如果第一次注册失败,第二次可以直接调用PushManager.getInstance().getRegister()进行重试,此方法默认会使用第一次传入的参数掉调用注册。</p>
<h3 id="4-%e6%b7%b7%e6%b7%86%e9%85%8d%e7%bd%ae">4. 混淆配置</h3>
<pre><code class="language-pro"><div>-keep public class * extends android.app.Service
</div></code></pre>
<h3 id="5-%e8%af%a6%e7%bb%86api%e8%af%b4%e6%98%8e">5. 详细API说明</h3>
<p>PushManager接口定义</p>
<pre><code class="language-java"><div><span class="hljs-comment">/**
     *判断是否手机平台是否支持PUSH
     *<span class="hljs-doctag">@param</span> context必须传入当前app的application context
     *<span class="hljs-doctag">@return</span> true 表示手机平台支持PUSH, false表示不支持
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSupportPush</span><span class="hljs-params">(Context context)</span>
 
     <span class="hljs-comment">/**
     * 注册OPush推送服务
     * @param applicatoinContext必须传入当前app的applicationcontet
     * @param appKey 在开发者网站上注册时生成的，与appID相对应，用于验证appID是否合法
     * @param pushCallback SDK操作的回调，如不需要使用所有回调接口，可传入PushAdapter，选择需要的回调接口来重写
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Context applicatoinContext, String appKey, String appSecret, PushCallback pushCallback)</span></span>;
 
    <span class="hljs-comment">/**
     * 设置appKey等参数,可以覆盖register中的appkey设置
     * <span class="hljs-doctag">@param</span> appKey 在开发者网站上注册时生成的key
     * <span class="hljs-doctag">@param</span> appSecret
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAppKeySecret</span><span class="hljs-params">(String appKey, String appSecret)</span></span>;
 
    <span class="hljs-comment">/**
     * 设置sdk操作回调处理,可以覆盖register中的PushCallback设置
     * <span class="hljs-doctag">@param</span> pushCallback sdk操作回调处理
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPushCallback</span><span class="hljs-params">(PushCallback pushCallback)</span></span>;
 
    <span class="hljs-comment">/**
     * 解注册OPush推送服务
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unRegister</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 获取注册OPush推送服务的注册ID
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getRegister</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 为指定用户设置aliases
     *
     * <span class="hljs-doctag">@param</span> aliases 为指定用户设置别名
     */</span>
<span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAliases</span><span class="hljs-params">(List&lt;String&gt; aliases)</span></span>;
 
    <span class="hljs-comment">/**
     * 取消指定用户的aliases
     *
     * <span class="hljs-doctag">@param</span> aliases 用户设置的别名
     */</span>
<span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unsetAliases</span><span class="hljs-params">(List&lt;String&gt; aliases)</span></span>;
 
    <span class="hljs-comment">/**
     * 方法返回了客户端设置的别名列表(如果客户端没有设置别名，则返回空列表)
     */</span>
<span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAliases</span><span class="hljs-params">()</span></span>;
 
     <span class="hljs-comment">/**
     * 为某个用户设置订阅topic
     *
     * <span class="hljs-doctag">@param</span> tags 用户设置的订阅topic
     */</span>
<span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setTags</span><span class="hljs-params">(List&lt;String&gt; tags)</span></span>;
 
    <span class="hljs-comment">/**
     * 取消某个用户的订阅topic
     *
     * <span class="hljs-doctag">@param</span> tags 用户设置的订阅topic
     */</span>
<span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unsetTags</span><span class="hljs-params">(List&lt;String&gt; tags)</span></span>;
 
    <span class="hljs-comment">/**
     * 方法返回了客户端订阅的主题列表(如果客户端没有订阅主题，则返回空列表)
     */</span>
<span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getTags</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 暂停接收OPush服务推送的消息
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pausePush</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 恢复接收OPush服务推送的消息，这时服务器会把暂停时期的推送消息重新推送过来
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resumePush</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 获取OPush推送服务状态
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPushState</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 获取OPush推送服务SDK版本
     *
     * <span class="hljs-doctag">@return</span> SDKVersion
     */</span>
    <span class="hljs-function">String <span class="hljs-title">getSDKVersion</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 获取OPush推送服务MCS版本
     *
     * <span class="hljs-doctag">@return</span> PushVersion
     */</span>
    <span class="hljs-function">String <span class="hljs-title">getPushVersion</span><span class="hljs-params">()</span></span>;
 
    <span class="hljs-comment">/**
     * 设置允许推送时间 API
     *
     * <span class="hljs-doctag">@param</span> weekDays 周日为0,周一为1,以此类推
     * <span class="hljs-doctag">@param</span> startHour 开始时间,24小时制
     * <span class="hljs-doctag">@param</span> endHour 结束时间,24小时制
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPushTime</span><span class="hljs-params">(List&lt;Integer&gt; weekDays, <span class="hljs-keyword">int</span> startHour, <span class="hljs-keyword">int</span> start         Min, <span class="hljs-keyword">int</span> endHour, <span class="hljs-keyword">int</span> endMin)</span></span>;
</div></code></pre>
<p>应用在没有获取到registerId时,需要先调用register进行初始化,初始化成功后才可以进行后续操作。如果调用register注册失败,可以调用getRegister使用上一次传入的参数进行重试。</p>
<p>PushCallback，PushAdapter</p>
<pre><code class="language-java"><div><span class="hljs-number">1</span>)接口定义
<span class="hljs-comment">//注册的结果,如果注册成功,registerID就是客户端的唯一身份标识</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onRegister</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, String registerID)</span></span>;
<span class="hljs-comment">//反注册的结果</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnRegister</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode)</span></span>;
 
<span class="hljs-comment">//alias操作结果,3个回调分别对应设置alias,取消alias,获取alias列表.如果操作成功,参数alias里面会包含操作成功的alias列表</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSetAliases</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; alias)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnsetAliases</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; alias)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onGetAliases</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; alias)</span></span>;
 
<span class="hljs-comment">//user account操作结果,3个回调分别对应设置account,取消account,获取account列表.如果操作成功,参数accounts里面会包含操作成功的account列表</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSetUserAccounts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; accounts)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnsetUserAccounts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; accounts)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onGetUserAccounts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; accounts)</span></span>;
 
<span class="hljs-comment">//订阅标签(tag)操作结果,3个回调分别对应设置tag,取消tag,获取tag列表.如果操作成功,参数tags里面会包含操作成功的tag列表</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSetTags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; tags)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnsetTags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; tags)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onGetTags</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode, List&lt;SubscribeResult&gt; tags)</span></span>;
 
<span class="hljs-comment">//获取当前的push状态返回,根据返回码判断当前的push状态,返回码具体含义可以参考[错误码]</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onGetPushStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode,<span class="hljs-keyword">int</span> status)</span></span>;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PushStatus</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PUSH_STATUS_START = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PUSH_STATUS_PAUSE = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PUSH_STATUS_STOP = <span class="hljs-number">2</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onGetNotificationStatus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> responseCode,<span class="hljs-keyword">int</span> status)</span></span>;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotificatoinStatus</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATUS_OPEN = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATUS_CLOSE = <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>所有回调都需要根据responseCode来判断操作是否成功，0 代表成功,其他代码失败，失败具体原因可以查阅附录中的错误码列表。</p>
<p>onRegister接口返回的registerID是当前客户端的唯一标识，app开发者可以上传保存到应用服务器中,在发送push消息是可以指定registerID发送。</p>
<p>alias,account,tag相关接口的返回参数中,如果操作成功，则参数中的List会返回操作成功的对象的列表,getxxx方法则会返回服务端保存的[alias/account/tag]列表。如果失败，则列表为空。</p>
<h3 id="6-%e9%94%99%e8%af%af%e7%a0%81%e5%ae%9a%e4%b9%89%e8%af%b4%e6%98%8e">6. 错误码定义说明</h3>
<p>参考类com.coloros.mcssdk.mode.ErrorCode中的错误码定义进行处理，详细如下：</p>
<p>1)ERROR = -2;  //initvalue初始值</p>
<p>2)SERVICE_CURRENTLY_UNAVAILABLE = -1;  //Service Currently Unavailable  服务不可用，此时请开发者稍候再试</p>
<p>3)SUCCESS = 0;  //成功，只表明接口调用成功</p>
<p>4)INSUFFICIENT_ISV_PERMISSIONS = 11;  //Insufficient ISV Permissions 无此API调用权限，开发者权限不足</p>
<p>5)HTTP_ACTION_NOT_ALLOWED = 12;  //Http Action Not Allowed HTTP 方法不正确</p>
<p>6)APP_CALL_LIMITED = 13;  //App Call Limited 应用调用次数超限，包含调用频率超限</p>
<p>7)INVALID_APP_KEY = 14;  // Invalid App Key 无效的AppKey参数</p>
<p>8)MISSING_APP_KEY = 15;  //Missing App Key 缺少AppKey参数</p>
<p>9)INVALID_SIGNATURE_SIGN = 16;  //Invalid Signature sign校验不通过，无效签名</p>
<p>10)MISSING_SIGNATURE = 17;  //Missing Signature 缺少签名参数</p>
<p>11)MISSING_TIMESTAMP = 18;  //Missing Timestamp 缺少时间戳参数</p>
<p>12)NVALID_TIMESTAMP = 19;  //Invalid Timestamp 非法的时间戳参数</p>
<p>13)INVALID_METHOD = 20;  //Invalid Method 不存在的方法名</p>
<p>14)MISSING_METHOD = 21;  //Missing Method 缺少方法名参数</p>
<p>15)MISSING_VERSION = 22;  //Missing Version 缺少版本参数</p>
<p>16)INVALID_VERSION = 23;  //Invalid Version 非法的版本参数，用户传入的版本号格式错误，必需为数字格式</p>
<p>17)UNSUPPORTED_VERSION = 24;  //Unsupported Version 不支持的版本号，用户传入的版本号没有被提供</p>
<p>18)INVALID_ENCODING = 25;  //Invalid encoding 编码错误，一般是用户做http请求的时候没有用UTF-8编码请求造成IP_BLACK_LIST = 26;//IP Black List IP黑名单</p>
<p>19)MISSING_REQUIRED_ARGUMENTS = 40;  //Missing Required Arguments 缺少必选参数 ，API文档中设置为必选的参数是必传的，请仔细核对文档20)INVALID_ARGUMENTS = 41;  //Invalid Arguments 参数错误，一般是用户传入参数非法引起的，请仔细检查入参格式、范围是否一一对应</p>
<h2 id="vivo%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1">vivo推送服务</h2>
<p>vivo推送支持标签全量、RegID、Alias、imei四种消息发送方式。有点类似小米，同样需要先在平台上注册申请，然后配置、下载SDK等等</p>
<p><strong>基于RegID的推送</strong></p>
<p>RegID为vivo推送为每个设备上的每个app注册推送服务时生成的唯一标示。</p>
<p>当开发者需要给一个或多个具体的设备推送消息时，可以使用基于 RegID的推送，将个性化的信息推送给指定的设备。这种方式适用于需要为每个用户订制个性化推送的场景。</p>
<p>注：</p>
<ul>
<li>
<p>RegID是在客户端向vivo推送服务注册时，vivo推送服务端根据设备标识、AppID以及当前时间戳生成，因此能够保证每个设备上每个app对应的regID都是不同的。</p>
</li>
<li>
<p>RegID在应用卸载或清除本地数据后会重新生成或者7天不联网</p>
</li>
<li>
<p>RegID在如下几种情况下会被判断失效：</p>
<p>① App卸载重装或者清除数据后重新注册，这种情况下会生成一个新的RegID，而老的RegID会失效；</p>
<p>② App调用了turnOffpush；</p>
<p>③ 在vivo 上，App卸载时，如果能成功上报，则RegID会被判定失效；</p>
<p>④ 设备超过7天没有和vivo Push服务器建立长连接；</p>
</li>
</ul>
<p><strong>基于Alias的推送</strong></p>
<p>alias是vivo推送提供的一种个性化设定, 开发者可以将用户在应用内的账号或其它用户唯一标识设定为用户设备 RegID 的别名，在推送中可以直接基于别名进行推送。</p>
<p>别名不仅方便开发者将推送与自有的账号系统进行关联，同时也避免了因需要保存设备 RegID 与自有帐号的对应关系而额外带来的开发和存储成本。</p>
<p>注：</p>
<ul>
<li>
<p>alias与RegID(设备)一一对应，同一个alias不能对应多个RegID，alias对应的RegID以最后一次setalias对应的RegID为准；</p>
</li>
<li>
<p>alias失效的可能原因如下：</p>
<p>①  主动调用unsetalias；</p>
<p>② alias对应的RegID已经失效；</p>
</li>
<li>
<p>alias只跟设备相关，所以请使用用户账号作为alias时，合理判断alias可能失效的情况。</p>
</li>
</ul>
<h3 id="1-%e5%af%bc%e5%85%a5%e6%8e%a8%e9%80%81jar%e5%8c%85">1. 导入推送jar包</h3>
<p>将解压后的libs文件夹中vivo_pushsdk-VERSION.jar(vivo_pushsdk-VERSION.jar为集成的jar包名字，VERSION为版本名称)拷贝到您的工程的libs文件夹中。</p>
<h3 id="2-%e9%85%8d%e7%bd%aeandroidmanifest%e6%96%87%e4%bb%b6">2. 配置AndroidManifest文件</h3>
<pre><code class="language-xml"><div><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">package</span>=<span class="hljs-string">"com.vivo.pushdemo.test"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>
        <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">"false"</span>
        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">"@mipmap/ic_launcher"</span>
        <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/app_name"</span>
        <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/AppTheme"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.push.sample.MainActivity"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">service</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.push.sdk.service.CommandClientService"</span>
            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.push.sdk.LinkProxyClientActivity"</span>
            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>
            <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">"portrait"</span>
            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- push应用定义消息receiver声明 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.push.sample.PushMessageReceiverImpl"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
                <span class="hljs-comment">&lt;!-- 接收push消息 --&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.pushclient.action.RECEIVE"</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.push.api_key"</span>
            <span class="hljs-attr">android:value</span>=<span class="hljs-string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.vivo.push.app_id"</span>
            <span class="hljs-attr">android:value</span>=<span class="hljs-string">"xxxxx"</span> /&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</div></code></pre>
<h3 id="3-%e5%90%af%e5%8a%a8%e4%ba%91%e6%8e%a8%e9%80%81">3. 启动云推送</h3>
<pre><code class="language-java"><div><span class="hljs-comment">// 建议Application的onCreate方法中执行</span>
PushClient.getInstance(getApplicationContext()).initialize();
PushClient.getInstance(getApplicationContext()).turnOnPush(<span class="hljs-keyword">new</span> IPushActionListener() {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStateChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>{
        <span class="hljs-keyword">if</span> (state != <span class="hljs-number">0</span>) {
            updateContent(<span class="hljs-string">"打开push异常["</span> + state + <span class="hljs-string">"]"</span>);
        } <span class="hljs-keyword">else</span> {
            updateContent(<span class="hljs-string">"打开push成功"</span>);
        }
    }
});
</div></code></pre>
<h3 id="4-%e8%87%aa%e5%ae%9a%e4%b9%89%e5%9b%9e%e8%b0%83%e7%b1%bb">4. 自定义回调类</h3>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PushMessageReceiverImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OpenClientPushMessageReceiver</span> </span>{
    <span class="hljs-comment">/**
     * TAG to Log
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = PushMessageReceiverImpl.class.getSimpleName();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationMessageClicked</span><span class="hljs-params">(Context context, UPSNotificationMessage msg)</span> </span>{
        String customContentString = msg.getSkipContent();
        String notifyString = <span class="hljs-string">"通知点击 msgId "</span> + msg.getMsgId() + <span class="hljs-string">" ;customContent="</span> + customContentString;
        Log.d(TAG, notifyString);

        <span class="hljs-comment">// Demo更新界面展示代码，应用请在这里加入自己的处理逻辑</span>
        updateContent(notifyString);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceiveRegId</span><span class="hljs-params">(Context context, String regId)</span> </span>{
        String responseString = <span class="hljs-string">"onReceiveRegId regId = "</span> + regId;
        Log.d(TAG, responseString);
        updateContent(responseString);
    }
}
</div></code></pre>
<h3 id="5-%e5%a4%84%e7%90%86%e6%8e%a8%e9%80%81%e6%b6%88%e6%81%af">5. 处理推送消息</h3>
<p>接收通知消息</p>
<p>当设备接收到通知消息后，查看手机的通知栏，可以看到通知栏内的该新通知展示。当点击通知时，回调PushMessageReceiverImpl#onNotificationMessageClicked方法。</p>
<h3 id="6-%e6%b7%b7%e6%b7%86%e8%af%b4%e6%98%8e">6. 混淆说明</h3>
<pre><code class="language-pro"><div>-downwarn com.vivo.push.**
-keep class com.vivo.push.**{*; }
-keep class xxx.xxx.xxx.PushMessageReceiverImpl{*;}
</div></code></pre>
<h2 id="%e9%ad%85%e6%97%8f%e6%8e%a8%e9%80%81%e6%9c%8d%e5%8a%a1">魅族推送服务</h2>
<p>功能基本类似上面几个推送服务(透传功能停用)，直接看Android端配置</p>
<h3 id="1-%e9%ad%85%e6%97%8f%e6%8e%a8%e9%80%81%e7%9a%84sdk%e5%8f%91%e5%b8%83%e5%88%b0jcenter%e6%89%80%e4%bb%a5%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87gradle%e5%af%bc%e5%85%a5">1. 魅族推送的SDK发布到jcenter，所以可以通过gradle导入</h3>
<pre><code class="language-gradle"><div><span class="hljs-keyword">dependencies</span> {
    <span class="hljs-keyword">compile</span> <span class="hljs-string">'com.meizu.flyme.internet:push-internal:3.8.3'</span>
}
</div></code></pre>
<h3 id="2-androidmanifestxml">2. AndroidManifest.xml</h3>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!-- 兼容 Flyme5 以下版本，魅族内部接入 PushSDK 必填，不然无法收到消息--&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.flyme.push.permission.RECEIVE"</span> /&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"【替换您的包名】.push.permission.MESSAGE"</span>
<span class="hljs-attr">android:protectionLevel</span>=<span class="hljs-string">"signature"</span>/&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"【替换您的包名】.push.permission.MESSAGE"</span> /&gt;</span>
 <span class="hljs-comment">&lt;!-- 兼容 Flyme3 配置权限--&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.c2dm.permission.RECEIVE"</span> /&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"【替换您的包名】.permission.C2D_MESSAGE"</span> <span class="hljs-attr">android:protectionLevel</span>=<span class="hljs-string">"signature"</span>
/&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"【替换您的包名】.permission.C2D_MESSAGE"</span>/&gt;</span>
</div></code></pre>
<p>注册消息接收的广播</p>
<pre><code class="language-xml"><div><span class="hljs-comment">&lt;!-- push 应用定义消息 receiver 声明 --&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"【替换您的包名】.MyPushMsgReceiver"</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
 <span class="hljs-comment">&lt;!-- 接收 push 消息 --&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.flyme.push.intent.MESSAGE"</span> /&gt;</span>
 <span class="hljs-comment">&lt;!-- 接收 register 消息 --&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.flyme.push.intent.REGISTER.FEEDBACK"</span> /&gt;</span>
 <span class="hljs-comment">&lt;!-- 接收 unregister 消息--&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.flyme.push.intent.UNREGISTER.FEEDBACK"</span>/&gt;</span>
 <span class="hljs-comment">&lt;!-- 兼容低版本 Flyme3 推送服务配置 --&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.c2dm.intent.REGISTRATION"</span> /&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.meizu.c2dm.intent.RECEIVE"</span> /&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"【替换您的包名】"</span> /&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>
</div></code></pre>
<h3 id="3-%e5%ae%9e%e7%8e%b0%e6%b6%88%e6%81%af%e6%8e%a5%e6%94%b6%e7%9a%84%e5%b9%bf%e6%92%ad">3. 实现消息接收的广播</h3>
<pre><code class="language-java"><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPushMsgReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MzPushMessageReceiver</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRegister</span><span class="hljs-params">(Context context, String s)</span> </span>{
        <span class="hljs-comment">// 调用旧版的订阅 PushManager.register(context) 方法后，</span>
        <span class="hljs-comment">// 会在此回调订阅状态（已废弃）</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-meta">@Deprecated</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnRegister</span><span class="hljs-params">(Context context, <span class="hljs-keyword">boolean</span> b)</span> </span>{
        <span class="hljs-comment">// 调用旧版的反订阅 PushManager.unRegister(context) 方法后，</span>
        <span class="hljs-comment">// 会在此回调反订阅状态（已废弃）</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRegisterStatus</span><span class="hljs-params">(Context context, RegisterStatus registerStatus)</span> </span>{
        <span class="hljs-comment">// 调用新版的订阅 PushManager.register(context,appId,appKey) 方法后，</span>
        <span class="hljs-comment">// 会在此回调订阅状态</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnRegisterStatus</span><span class="hljs-params">(Context context, UnRegisterStatus unRegisterStatus)</span> </span>{
        <span class="hljs-comment">// 调用新版的反订阅 PushManager.unRegister(context,appId,appKey) 方法后，</span>
        <span class="hljs-comment">// 会在此回调订阅状态</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPushStatus</span><span class="hljs-params">(Context context, PushSwitchStatus pushSwitchStatus)</span> </span>{
        <span class="hljs-comment">// 调用 PushManager.switchPush/checkPush 方法后，</span>
        <span class="hljs-comment">// 会在此回调通知栏和透传消息的开关状态</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubTagsStatus</span><span class="hljs-params">(Context context, SubTagsStatus subTagsStatus)</span> </span>{
        <span class="hljs-comment">// 调用 PushManager.subScribeTags/unSubScribeTags/unSubScribeAllTags</span>
        <span class="hljs-comment">// /checkSubScribeTags 方法后，会在此回调标签相关信息</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubAliasStatus</span><span class="hljs-params">(Context context, SubAliasStatus subAliasStatus)</span> </span>{
        <span class="hljs-comment">// 调用 PushManager.subScribeAlias/unSubScribeAlias/checkSubScribeAlias</span>
        <span class="hljs-comment">// /checkSubScribeTags 方法后，会在此回调别名相关信息</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpdateNotificationBuilder</span><span class="hljs-params">(PushNotificationBuilder pushNotificationBuilder)</span> </span>{
        <span class="hljs-comment">// 兼容旧版本 Flyme 系统中设置消息弹出后状态栏中的小图标</span>
        <span class="hljs-comment">// 同时请在相应的 drawable 不同分辨率文件夹下放置一张名称务必为</span>
        <span class="hljs-comment">// mz_push_notification_small_icon 的图片</span>
        pushNotificationBuilder.setmStatusbarIcon(R.drawable.mz_push_notification_small_icon);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationClicked</span><span class="hljs-params">(Context context, MzPushMessage mzPushMessage)</span> </span>{
        <span class="hljs-comment">// 当用户点击通知栏消息后会在此方法回调</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotificationArrived</span><span class="hljs-params">(Context context, MzPushMessage mzPushMessage)</span> </span>{
        <span class="hljs-comment">// 当推送的通知栏消息展示后且应用进程存在时会在此方法回调</span>
    }
}
</div></code></pre>
<h3 id="4-application-oncreate">4. Application onCreate</h3>
<pre><code class="language-java"><div>PushManager.register(<span class="hljs-keyword">this</span>, APP_ID, APP_KEY);
</div></code></pre>

    </body>
    </html>